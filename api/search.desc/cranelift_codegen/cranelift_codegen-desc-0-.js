searchState.loadedDescShard("cranelift_codegen", 0, "Cranelift code generation library.\nThe ABI machine spec for this <code>MachInst</code>.\nOffset from the Canonical Frame Address (aka CFA).\nThe code size for the function is too large.\nA compilation error.\nA convenient alias for a <code>Result</code> that uses <code>CodegenError</code> as …\nCompilation error, with the accompanying function to help …\n<code>CompiledCode</code> in its final form (i.e. after …\nPersistent data structures and compilation pipeline.\nContains the error value\nPoints to an ExternalName outside the current function.\nTarget of relocation could be anywhere in the address …\nStatus of a compiled artifact ready to use.\nA relocation resulting from a compilation.\nA Relocation target\nPoints to a CodeOffset from the start of the current …\nA constant value generated during lowering; the value may …\nAn implementation limit was exceeded.\nConstant information used in <code>emit</code> invocations.\nA label-use kind: a type that describes the types of label …\nThe particular location for a value.\nA buffer of output to be produced, fixed up, and then …\nA <code>MachBuffer</code> once emission is completed: holds generated …\nA call site record resulting from a compilation.\nA machine instruction.\nA trait describing the ability to encode a MachInst into …\nA trait describing the emission state carried between …\nA label refers to some offset in a <code>MachBuffer</code>. It may not …\nA source-location mapping resulting from a compilation.\nRecord of stack map metadata: stack offsets containing …\nImplementation of the <code>TextSectionBuilder</code> trait backed by …\nA trap record resulting from a compilation.\nTarget of relocation is “nearby”. The threshold for …\nContains the success value\nRepresents the beginning of an editable region in the …\nA region in the <code>MachBuffer</code> code buffer that can be edited …\nProof-carrying-code validation error.\nA constant already present in the Cranelift IR ConstantPool…\nA real (physical) register. This corresponds to one of the …\nA register named in an instruction. This register can be …\nRegister.\nRegister allocator internal error discovered by the …\nA failure to map Cranelift register representation to a …\nNotion of “relocation distance”. This gives an …\nPersistent state carried across <code>emit</code> invocations.\nByte representation of a trap opcode which is inserted by …\nAn object that can be used to create the text section of …\nA constant of at most 64 bits. These are deduplicated as …\nSomething is not supported by the code generator. This …\nIdentify the different types of constant that can be …\nThis structure tracks the large constants used in VCode …\nVersion number of this crate. \nResulting map of Value labels and their ranges/locations.\nValue location range.\nA list of IR verifier errors.\nA reference to a well-known constant value that is …\nA type wrapper that indicates a register type is writable. …\nAdd a call-site record at the current offset.\nInform the buffer of a conditional branch at the given …\nAdd an external relocation at the current offset.\nAdd an external relocation at the given offset from …\nAdd stack map metadata for this program point: a set of …\nAdd a trap record at the current offset.\nInform the buffer of an unconditional branch at the given …\nAdd an unwind record at the current offset.\nThe addend to add to the symbol value.\nAlign a basic block offset (from start of function).  By …\nAlign a basic block offset (from start of function).  By …\nAlign up to the given alignment.\nCalculate the alignment of the constant data.\nThe requireed alignment of this buffer\nAppends <code>data</code> to the text section with the <code>align</code> specified.\nGet a finalized machine buffer by applying the function’…\nReturn the raw bit encoding for this instance.\nRetrieve the constant data as a byte slice.\nReturn the underlying index value as a <code>u32</code>.\nBasic-block layout info: block edges. Each edge is …\nBasic-block layout info: block start offsets.\nBind a label to the current offset. A label can only be …\nBinary machine code emission.\nMachine code.\nGet the list of call sites for this code.\nGet an appropriate type that can fully hold a value in a …\nPerform NaN canonicalizing rewrites on the function.\nThe control flow graph of <code>func</code>.\nThe <code>CFGPrinter</code> utility.\nGet the class of this register.\nGet the class of this register.\nClear all data structures in this context.\nThe trap code.\nCompile the function.\nCompile the function, and emit machine code into a <code>Vec&lt;u8&gt;</code>.\nInternally compiles the function into a stencil.\nCompile the function, as in <code>compile</code>, but tries to reuse …\nReturns the compilation result for this function, …\nCompute the control flow graph.\nCompute dominator tree.\nCompute the loop analysis.\nCreates unwind information for the function.\nCreates unwind information for the function.\nCreates unwind information for the function using the …\nThe emission state holds ownership of a control plane, so …\nCurrent offset from start of buffer.\nCursor library.\nGet the code bytes.\nThis module gives users to instantiate values that …\nDebug tracing helpers.\nEmit a trap at some point in the future with the specified …\nReturns a display for the current FinalizedRelocTarget, …\nA Dominator Tree represented as mappings of Blocks to …\nDominator tree for <code>func</code>.\nDebug info: stackslots to stack pointer offsets.\nRun optimizations via the egraph infrastructure.\nPerform unreachable code elimination.\nEmit the instruction.\nEmit all pending constants and required pending veneers.\nThe end of the region of code corresponding to a source …\nThe end of the range. It is an offset in the generated …\nEnd a region of patchable code, yielding a <code>PatchRegion</code> …\nMark the end of the <code>SourceLoc</code> segment started at the last …\nCompletes this text section, filling out any final …\nFinish any deferred emissions and/or fixups.\nA control flow graph represented as mappings of basic …\nCompute the control flow graph and dominator tree.\nAllocate a new compilation context with an existing …\nA debug-only option which is used to for\nThe <code>FrameLayout</code> for the function currently being compiled.\nSize of stack frame, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nGet a label for a block. (The first N MachLabels are …\nExplicitly construct a <code>Writable&lt;T&gt;</code> from a <code>T</code>. As noted in …\nCreate a new instance from a <code>u32</code>.\nThe function we’re compiling.\nFunction we tried to compile, for display purposes.\nReturns a description of the alignment required for …\nGenerate an instruction that must appear at the beginning …\nGenerate an instruction that must appear at the beginning …\nGenerate a dummy instruction that will keep a value alive …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a jump to another target. Used during lowering of …\nGenerate a move.\nGenerate a NOP. The <code>preferred_size</code> parameter allows the …\nReturns the data associated with the specified constant.\nGet the numeric label index.\nReserve appended space and return a mutable slice …\nIf available, return information about the code layout in …\nIf available, return information about the code layout in …\nAllocate a <code>Label</code> to refer to some offset. May not be bound …\nReturns a label that can be used to refer to the <code>constant</code> …\nReturn the registers referenced by this machine …\nGet a list of source location mapping tuples in …\nThe physical register number.\nThis module provides a set of primitives that allow …\nUnderlying <code>CodegenError</code> that triggered the error.\nInsert a constant; using this method indicates that a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of Cranelift IR functions.\nIs this an “args” pseudoinst?\nShould this instruction be included in the clobber-set?\nDoes this instruction access memory?\nIf this is a simple move, return the (source, destination) …\nIs this a real (physical) reg?\nIs this a safepoint?\nIs this a terminator (branch or ret)? If so, return its …\nIs this an unconditional trap?\nIs this a virtual reg?\nInstruction Set Architectures.\nIs an island needed within the next N bytes?\nIterate over the <code>VCodeConstant</code> keys and the data (as a …\nIterate over the <code>VCodeConstant</code> keys inserted in this …\nThe kind of relocation.\nRun the legalizer for <code>isa</code> on the function.\nReturn the number of constants inserted.\nThe source location.\nThe ValueLoc containing a ValueLabel during this range.\nA loop analysis represented as mappings of loops to their …\nLoop analysis of <code>func</code>.\nMap the underlying register to another value or type.\nCreate a new emission state given the ABI object.\nCreate a new section, known to start at <code>start_offset</code> and …\nCreates a new text section builder which will have …\nAllocate a new compilation context.\nThe offset at which the relocation applies, <em>relative to the</em>\nThe offset at which the trap instruction occurs, <em>relative </em>…\nThe code offset at which this stack map applies.\nThe code offset just past the “end” of the …\nA hook that triggers when first emitting a new block. It …\nA hook that triggers when first emitting a new block. It …\nThe call’s opcode.\nOptimize the function, performing all compilation steps up …\nPerforms various optimizations on branches pointing at the …\nCompact representation of <code>Option&lt;T&gt;</code> for types with a …\nConsume the patch region to yield a mutable slice of the …\nChecks if the given VCodeConstantData is registered as …\nUpdate the emission state before emitting an instruction …\nUpdate the emission state before emitting an instruction …\nPretty-print the instruction.\nUtility routines for pretty-printing error messages.\nAdd a byte.\nAdd 2 bytes.\nAdd 4 bytes.\nAdd 8 bytes.\nAdd a slice of bytes.\nDetermine register class(es) to store the given Cranelift …\nWhat is the register class used for reference types …\nSimilar to <code>MachBuffer::register_constants</code> but registers a …\nRegisters metadata in this <code>MachBuffer</code> about the <code>constants</code> …\nGet the list of external relocations for this code.\nPerform constant-phi removal on the function.\nReplace all redundant loads with the known values in …\nReserve the first N MachLabels for blocks.\nAttempts to resolve a relocation for this function.\nThe offset of the call’s return address, <em>relative to the </em>…\nSet the flag to request a disassembly when compiling with a\nShared settings module.\nDebug info: stackslots to stack pointer offsets.\nHarvest candidate left-hand sides for superoptimization …\nThe stack map itself.\nGet the stack map metadata for this code.\nThe start of the region of code corresponding to a source …\nThe start of the range. It is an offset in the generated …\nBegin a region of patchable code. There is one requirement …\nSet the <code>SourceLoc</code> for code from this offset until the …\nReturn the code in this mach buffer as a hex string for …\nUsed to continue using a control plane after the emission …\nThe external symbol / name to which this relocation refers.\nPass timing.\nGet the physical register (<code>RealReg</code>), if this register is …\nGet the underlying register, which can be read.\nCreates a string representing this label, for convenience.\nGet the virtual (non-physical) register, if this register …\nGet the total required size for the code.\nEven when trace logging is disabled, the trace macro has a …\nGet the list of trap records for this code.\nTraversals over the IR.\nAny unwind info at a given location.\nEmit a reference to the given label with the given …\nDebug info: value labels to registers/stackslots at code …\nDisassembly, if requested.\nA verifier for ensuring that functions are well formed. It …\nRun the verifier on the function.\nRun the verifier only if the <code>enable_verifier</code> setting is …\nFlag: do we want a disassembly with the CompiledCode?\nInitialize the structure with the expected number of …\nWhat is the worst-case instruction size emitted by this …\nConverting Cranelift IR to text.\nAArch64 GOT Page Set the immediate value of an ADRP to …\nAArch64 GOT Low bits Set the LD/ST immediate field to bits …\nAarch64 TLSDESC Add Lo12 This is equivalent to …\nAarch64 TLSDESC Adr Page21 This is equivalent to …\nAarch64 TLSDESC Call This is equivalent to …\nAarch64 TLSDESC Ld64 Lo12 This is equivalent to …\nabsolute 4-byte\nabsolute 8-byte\nAddend to add to the symbol value.\nArm32 call target\nArm64 call target. Encoded as bottom 26 bits of …\nContainer for information about a vector of compiled code …\nOffset in bytes from the beginning of the function.\nElf x86_64 32 bit signed PC relative offset to two GOT …\nMach-O Aarch64 TLS PC-relative distance to the page of the …\nMach-O Aarch64 TLS Offset within page of TLVP slot.\nMach-O x86_64 32 bit signed PC relative offset to a …\nRelocation kinds for every ISA\nRISC-V Call PLT: 32-bit PC-relative function call, macros …\nHigh 20 bits of a 32-bit PC-relative GOT offset relocation\nLow 12 bits of a 32-bit PC-relative relocation (I-Type …\nRISC-V TLS GD: High 20 bits of 32-bit PC-relative TLS GD …\ns390x PC-relative 4-byte offset\ns390x PC-relative 4-byte offset to PLT\ns390x TLS GD64 - 64-bit offset of tls_index for GD symbol …\ns390x TLS GDCall - marker to enable optimization of TLS …\nStack maps record which words in a stack frame contain …\nx86 call to PC-relative 4-byte\nx86 call to PLT-relative 4-byte\nx86 GOT PC-relative 4-byte\nx86 PC-relative 4-byte\nThe 32-bit offset of the target from the beginning of its …\nReturns the raw bitmap that represents this stack map.\nDisplay trait implementation drops the arch, since its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a vec of Bitsets from a slice of bools.\nReturns a specified bit.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of words represented by this stack map.\nNumber of bytes in total.\nA utility for pretty-printing the CFG of a <code>Function</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new CFGPrinter.\nWrite the CFG for this function to <code>w</code>.\nCursor is pointing after the end of a block. New …\nCursor is pointing at an existing instruction. New …\nCursor is before the beginning of a block. No instructions …\nAll cursor types implement the <code>Cursor</code> which provides …\nThe possible positions of a cursor.\nFunction cursor.\nCursor is not pointing anywhere. No instructions can be …\nRebuild this cursor positioned after <code>inst</code>.\nRebuild this cursor positioned at the bottom of <code>block</code>.\nRebuild this cursor positioned at the first insertion …\nRebuild this cursor positioned at the first instruction in …\nRebuild this cursor positioned at <code>inst</code>.\nRebuild this cursor positioned at the last instruction in …\nRebuild this cursor positioned at <code>pos</code>.\nRebuild this cursor positioned at the top of <code>block</code>.\nGet the block corresponding to the current position.\nGet the instruction corresponding to the current position, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe referenced function.\nGo to the position after a specific instruction, which …\nGo to the bottom of <code>block</code> which must be inserted into the …\nGo to the position for inserting instructions at the …\nGo to the first instruction in <code>block</code>.\nGo to a specific instruction which must be inserted in the …\nGo to the last instruction in <code>block</code>.\nGo to the top of <code>block</code> which must be inserted into the …\nCreate an instruction builder that inserts an instruction …\nInsert a block at the current position and switch to it.\nInsert an instruction at the current position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBorrow a reference to the function layout that this cursor …\nBorrow a mutable reference to the function layout that …\nCreate a new <code>FuncCursor</code> pointing nowhere.\nGo to the top of the next block in layout order and return …\nMove to the next instruction in the same block and return …\nGet the current cursor position.\nGo to the bottom of the previous block in layout order and …\nMove to the previous instruction in the same block and …\nRemove the instruction under the cursor.\nRemove the instruction under the cursor.\nSet the current position.\nSet the source location that should be assigned to new …\nGet the source location that should be assigned to new …\nUse the source location of <code>inst</code> for future instructions.\nExchange this cursor for one with a set source location.\nRepresent a data value. Where Value is an SSA reference, …\nRecord failures to cast DataValue.\nHelper structure for printing bracket-enclosed vectors of …\nPerforms a bitwise comparison over the contents of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to cast an immediate integer (a wrapped <code>i64</code> on most …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the value is a vector (i.e. <code>DataValue::V128</code>…\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type with …\nRead a DataValue from a memory location using a given Type …\nConverts <code>self</code> to big endian from target’s endianness.\nConverts <code>self</code> to little endian from target’s endianness.\nReturn the Cranelift IR Type for this DataValue.\nHelper function for displaying <code>Vec&lt;DataValue&gt;</code>.\nWrite a DataValue to a slice in big-endian byte order.\nWrite a DataValue to a slice in little-endian byte order.\nWrite a DataValue to a slice in native-endian byte order.\nWrite a DataValue to a memory location in native-endian …\nHelper for printing lists.\nPrefix added to the log file names, just before the thread …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator that enumerates the direct children of a block …\nThe dominator tree for a single function.\nOptional pre-order information that can be computed for a …\nGet the CFG post-order of blocks that was used to compute …\nGet an iterator over the direct children of <code>block</code> in the …\nClear the data structures used to represent the dominator …\nCompute the common dominator of two basic blocks.\nReset and compute a CFG post-order and dominator tree.\nRecompute this data structure to match <code>domtree</code>.\nReturns <code>true</code> if <code>a</code> dominates <code>b</code>.\nFast, constant time dominance check with block granularity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> reachable from the entry block?\nCheck if the dominator tree is in a valid state.\nFind the last instruction in <code>a</code> that dominates <code>b</code>. If no …\nAllocate a new blank dominator tree. Use <code>compute</code> to …\nCreate a new blank <code>DominatorTreePreorder</code>.\nCompare two program points according to the dominator tree …\nCompare two blocks according to the dominator pre-order.\nCompare two program points relative to a reverse …\nCompare two blocks relative to the reverse post-order.\nAllocate and compute a dominator tree.\nA basic block denoted by its enclosing Block and last …\nThe Control Flow Graph maintains a mapping of blocks to …\nAn iterator over block predecessors. The iterator type is …\nAn iterator over block successors. The iterator type is …\nEnclosing Block key.\nClear all data structures in this control flow graph.\nCompute the control flow graph of <code>func</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLast instruction in the basic block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the CFG is in a valid state.\nAllocate a new blank control flow graph.\nConvenient method to construct new BlockPredecessor.\nGet an iterator over the CFG predecessors to <code>block</code>.\nRecompute the control flow graph of <code>block</code>.\nGet an iterator over the CFG successors to <code>block</code>.\nAllocate and compute the control flow graph for <code>func</code>.\nHashed <code>CachedKey</code>, to use as an identifier when looking up …\nBacking storage for an incremental compilation cache, when …\nAn error occurred while deserializing the cache entry.\nAn error returned when recompiling failed.\nThe version embedded in the cache entry isn’t the same …\nCompute a cache key, and hash it on your behalf.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven a cache key hash, retrieves the associated opaque …\nGiven a new cache key and a serialized blob obtained from …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a function that’s been successfully compiled, …\nGiven a function that’s been precompiled and its entry …\nFunction parameter or return value descriptor.\nAdd\nA value alias to original value.\nWhich disjoint region of aliasing memory is accessed in …\nAnd\nFunction argument extension options.\nThe special purpose of a function argument.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nDescribes the arithmetic operation in an atomic memory …\nFailed float-to-int conversion.\nSignature mismatch on indirect call.\nBig-endian\nBinary(imms=(), vals=2, blocks=0)\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nA block header.\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\nBrif(imms=(), vals=1, blocks=2)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nceil.f32\nceil.f64\nTLS index symbol for the current thread. Used in COFF/PE …\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nValue is a multiple of how many instances of <code>vector_type</code> …\nA dynamically-sized untyped blob of memory, with bound …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nELF well-known linker symbol <em>GLOBAL_OFFSET_TABLE</em>\nElf __tls_get_addr\nElf __tls_get_offset\nA type with no size.\nEndianness of a memory access.\nAn external function.\nThe name of an external is either a reference to a …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nfloor.f32\nfloor.f64\nfma.f32\nfma.f64\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nInformation about a global value declaration.\nA wasm atomic operation was presented with a …\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nValue is an offset from another global value.\nIndirect call to a null table entry.\nBuilder that inserts an instruction at the current …\nAn instruction in the function.\nConvenience methods for building instructions.\nBase trait for instruction builders.\nBase trait for instruction inserters.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nExecution has potentially run too long and may be …\nJump(imms=(), vals=0, blocks=1)\nJump(imms=(), vals=0, blocks=1)\nMap of jump tables.\nA well-known symbol.\nA well-known symbol.\nThe name of a runtime library routine.\nA well-known runtime library function.\nLittle-endian\nLoad(imms=(flags: ir::MemFlags, offset: …\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nFlags for memory operations like load/store.\nlibc.memcmp\nlibc.memcpy\nlibc.memmove\nA statically-sized untyped blob of memory.\nData defining a memory type.\nOne field in a memory type.\nlibc.memset\nMultiAry(imms=(), vals=0, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\nNand\nnearest.f32\nnearest.f64\nNo extension, high bits are indeterminate.\nA normal user program value passed to or from a function.\nNullAry(imms=(), vals=0, blocks=0)\nNullAry(imms=(), vals=0, blocks=0)\nA null <code>i31ref</code> was encountered which was required to be …\nA null reference was encountered which was required to be …\nOr\nprobe for stack overflow. These are emitted for functions …\nA <code>ProgramPoint</code> represents a position in a function where …\nSource location relative to another base source location.\nInstruction builder that replaces an existing instruction.\nSigned extension: high bits in register replicate sign bit.\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nFunction signature.\nSigned max\nSigned min\nA source location.\nA stack limit pointer.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nThe current stack space was exhausted.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nOriginal value labels assigned at transform.\nStore(imms=(flags: ir::MemFlags, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nAn aggregate consisting of certain fields at certain …\nA C struct passed as argument.\nStruct return pointer.\nSub\nValue is symbolic, meaning it’s a name which will be …\nA <code>table_addr</code> instruction detected an out-of-bounds error.\nTernary(imms=(), vals=3, blocks=0)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nA name for a test case, mostly intended for Cranelift …\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nA trap code describing the reason for a trap.\ntrunc.f32\nfrunc.f64\nUnsigned extension: high bits in register are 0.\nUnsigned max\nUnsigned min\nUnary(imms=(), vals=1, blocks=0)\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nCode that was supposed to have been unreachable was …\nA user-defined name, with semantics left to the user.\nA reference to a name in a user-defined symbol table.\nA user-defined trap code.\nAn external name in a user-defined symbol table.\nAn explicit name for a user-defined function, be it …\nA VM context pointer.\nValue is the address of the VM context struct.\nMarked with a label value.\nValue label assignments: label starts or value aliases.\nA label of a Value.\nThe <code>pshufb</code> on x86 when SSSE3 isn’t available.\nExchange\nXor\nReads the alias region that this memory operation works …\nTest if the <code>aligned</code> flag is set.\nReturns a slice with all supported AtomicRmwOp’s.\nGet a list of all known <code>LibCall</code>’s.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and.\nBitwise and with immediate.\nBitwise and with immediate.\nBitwise and not.\nBitwise and not.\nReinterpret the bits in <code>x</code> as a different type.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReverse the bits of a integer.\nRead the bits of this source location.\nConditional select of bits.\nConditional select of bits.\nConvert <code>x</code> to an integer mask.\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise not.\nBitwise or.\nBitwise or.\nBitwise or with immediate.\nBitwise or with immediate.\nBitwise or not.\nBitwise or not.\nIndirect branch via jump table.\nIndirect branch via jump table.\nConditional branch when cond is non-zero.\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nReverse the byte order of an integer.\nInsert an instruction and return a reference to it, …\nBitwise xor.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor with immediate.\nBitwise xor not.\nBitwise xor not.\nDirect function call.\nDirect function call.\nCalling convention.\nIndirect function call.\nIndirect function call.\nRound floating point round to integral, towards positive …\nRound floating point round to integral, towards positive …\nTest if the <code>checked</code> bit is set.\nClear the signature so it is identical to a fresh one …\nCount leading sign bits.\nCount leading sign bits.\nCount leading zero bits.\nCount leading zero bits.\nWill this function be defined nearby, such that it will …\nCondition codes for the Cranelift code generator.\nConstants\nCount trailing zeros.\nCount trailing zeros.\nGet an immutable reference to the data flow graph that …\nGet an immutable reference to the data flow graph.\nGet a mutable reference to the data flow graph that will …\nGet a mutable reference to the data flow graph.\nEncodes an assembly debug trap.\nEncodes an assembly debug trap.\nData flow graph tracking Instructions, Values, and blocks.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nGet the address of a dynamic stack slot.\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nStore a value to a dynamic stack slot.\nDynamic IR types\nReturn endianness of the memory access.  This will return …\nCranelift IR entity references.\nExpands the relative source location into an absolute one, …\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point absolute value.\nGet the fact, if any, on a field.\nA proof-carrying-code fact about this value, if any.\nFloating point addition.\nFloating point addition.\nFloating point comparison.\nFloating point comparison.\nFloating point copy sign.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConvert unsigned integer to floating point.\nConverts floating point scalars to signed integer.\nConverts floating point scalars to signed integer.\nConvert floating point to signed integer as fcvt_to_sint …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nA memory fence.  This must provide ordering to ensure …\nRound floating point round to integral, towards negative …\nRound floating point round to integral, towards negative …\nFloating point fused multiply-and-add.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point maximum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point multiplication.\nFloating point multiplication.\nFloating point negation.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSource location when it is in effect\nCreates a new <code>RelSourceLoc</code> based on the given base and …\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nFloating point subtraction.\nGet the address of a function.\nGet the address of a function.\nIntermediate representation of a function.\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGets the content of the pinned register, when it’s …\nGet a function reference for the probestack function in …\nGet the PC where this function will transfer control to …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nGet the address in the stack pointer register.\nGet a <code>UserExternalName</code> if this is a user-defined name.\nReturn the type of this global.\nCompute the value of global GV.\nCompute the value of global GV.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd integers with carry in and out.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd integers with carry in.\nAdd immediate integer.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nInteger comparison.\nCompare scalar integer to a constant.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nInteger constant.\nImmediate operands for Cranelift instructions\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nInteger multiplication by immediate constant.\nArbitrary.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInsert a new instruction which belongs to the DFG.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInstruction formats and opcodes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nImmediate reverse wrapping subtraction: …\nIs this the default source location?\nIs this the default relative source location?\nReference verification.\nReference verification.\nDoes this return more than one normal value? (Pre-struct …\nReference verification.\nReference verification.\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nSubtract integers with borrow in.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nSubtract integers with borrow in and out.\nJump.\nJump.\nJump table representation.\nThe label index.\nFunction layout.\nLoad from memory at <code>p + Offset</code>.\nLoad from memory at <code>p + Offset</code>.\nName of the external function.\nArbitrary.\nRound floating point round to integral, towards nearest …\nRound floating point round to integral, towards nearest …\nCreate a new builder which inserts instructions at <code>pos</code>. …\nCreate a <code>ReplaceBuilder</code> that will overwrite <code>inst</code>.\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreates a new UserExternalName.\nCreate a new empty set of flags.\nCreate a new source location with the given bits.\nCreate a new relative source location with the given bits.\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nJust a dummy instruction.\nTest if this memory operation cannot trap.\nNull constant value for reference types.\nNull constant value for reference types.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nThe offset of this field in the memory type.\nThe arguments passed to the function.\nProof-carrying code. We attach “facts” to values and …\nPopulation count\nPopulation count\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nWhether this field is read-only, i.e., stores should be …\nA resumable trap.\nA resumable trap.\nA resumable trap to be called when the passed condition is …\nA resumable trap to be called when the passed condition is …\nReturn from the function.\nReturn from the function.\nDirect tail call.\nDirect tail call.\nIndirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left.\nRotate left by immediate.\nRotate left by immediate.\nRotate right.\nRotate right.\nRotate right by immediate.\nRotate right by immediate.\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd with signed saturation.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nSigned integer division by an immediate constant.\nConditional select.\nConditional select.\nConditional select intended for Spectre guards.\nConditional select intended for Spectre guards.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet the <code>checked</code> bit.\nSet endianness of the memory access.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>.\nSets the content of the pinned register, when it’s …\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSIMD vector shuffle.\nGet a Signature for the function targeted by this LibCall.\nCall signature of function.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nSigned integer maximum.\nSigned integer maximum.\nSigned integer minimum.\nSigned integer minimum.\nMultiply integers signed with overflow out. <code>of</code> is set when …\nMultiply integers signed with overflow out. <code>of</code> is set when …\nSigned integer multiplication, producing the high half of a\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nVector splat.\nFixed-point multiplication of numbers in the QN format, …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nFloating point square root.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSigned shift right by immediate.\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract with signed saturation.\nSubtract with signed saturation.\nGet the address of a stack slot.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nStore a value to a stack slot at a constant offset.\nStack slots.\nProvide the static size of this type, if known.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nVector swizzle.\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCompute the value of global GV, which is a symbolic value.\nCreates a new external name from a sequence of bytes. …\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nCompute the value of global GV, which is a TLS (thread …\nTerminate execution unconditionally.\nTerminate execution unconditionally.\nGet the trap code to report if this memory access traps.\nTrap when non-zero.\nTrap when non-zero.\nTrap when zero.\nTrap when zero.\nRound floating point round to integral, towards zero.\nRound floating point round to integral, towards zero.\nCreate a set of flags representing an access from a “…\nThe primitive type of the value in this field. Accesses to …\nCommon types for the Cranelift code generator.\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nUnsigned addition of x and y, trapping if the result …\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer maximum.\nUnsigned integer minimum.\nUnsigned integer minimum.\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nUnsigned integer multiplication, producing the high half …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the instruction we know is inside.\nUnsigned integer remainder.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nUnsigned integer remainder with immediate divisor.\nCreate a new external name from a user-defined external …\nCreate a new external name from a user-defined external …\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nUnsigned shift right by immediate.\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract with unsigned saturation.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nSIMD vector constant.\nReduce a vector to a scalar integer.\nReduce a vector to a scalar integer.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag, returning new flags.\nSet the <code>checked</code> bit, returning new flags.\nSet endianness of the memory access, returning new flags.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>, returning …\nSet the <code>readonly</code> flag, returning new flags.\nReuse a single result value.\nReuse result values in <code>reuse</code>.\nConfigures these flags with the specified trap code <code>code</code>.\nA bitselect-lookalike instruction except with the …\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nA vector swizzle lookalike which has the semantics of …\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nSpecifies the memory flags to be used by the load. …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nFields in this type. Sorted by offset.\nDynamic part of size.\nSize of this type.\nAccessible size.\nStatic part of size.\nSource location when it is in effect\nThe label index.\nCommon traits of condition codes.\n<code>==</code>.\nEQ\nCondition code for comparing floating point numbers.\nGT\nGT | EQ\nCondition code for comparing integers.\nLT\nLT | EQ\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nEQ | LT | GT\nLT | GT\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nGet the complemented condition code of <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the swapped args condition code for <code>self</code>.\nGet the corresponding string condition code for the IntCC …\nGet the corresponding IntCC with the signed component …\nGet the corresponding IntCC with the equal component …\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\nAdd new bytes to the constant data.\nReturn the data as a slice.\nReturn the combined size of all of the constant values in …\nEmpty the constant pool of all data.\nIterate over mutable entries in the constant pool in …\nExpand the size of the constant data to <code>expected_size</code> …\nPrint the constant data in hexadecimal format, e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a hexadecimal string to <code>ConstantData</code>. This is the …\nRetrieve the constant data given a handle.\nInsert constant data into the pool, returning a handle for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the data to a vector.\nCheck if the constant contains any bytes.\nIterate over the constant’s bytes.\nIterate over the constants in insertion order.\nReturn the number of bytes in the constant.\nReturn the number of constants in the pool.\nCreate a new constant pool instance.\nLink a constant handle to its value. This does not …\nContents of a basic block.\nStorage for basic blocks within the DFG.\nA data flow graph defines all instructions and basic …\nObject that can display an instruction.\nStorage for instructions within the DFG.\nValue is the n’th parameter to a block.\nValue is the n’th result of an instruction.\nValue is a union of two other values.\nWhere did a value come from?\nIterator over all Values in a DFG.\nCreate a new basic block.\nInserts a <code>ValueLabelAssignments::Alias</code> for <code>to_alias</code> if …\nAppend a parameter with type <code>ty</code> to <code>block</code>.\nSimilar to <code>append_block_param</code>, append a parameter with …\nAppend an existing value to <code>block</code>’s parameters.\nMake a BlockCall, bundling together the block and its …\nReturns <code>true</code> if the given block reference is valid.\nGet the types of the parameters on <code>block</code>.\nGet the parameters on <code>block</code>.\nbasic blocks in the function and their parameters.\nGet the call signature of a direct or indirect call …\nTurn a value into an alias of another.\nCheck that the given concrete <code>Type</code> has been defined in the …\nClear everything.\nClear the list of result values from <code>inst</code>.\nClone an instruction, attaching new result <code>Value</code>s and …\nStarts collection of debug information.\nCompute the type of an instruction result from opcode …\nConstants used within the function.\nGet the controlling type variable, or <code>INVALID</code> if <code>inst</code> isn…\nDetach all the parameters from <code>block</code> and return them as a …\nReturns an object that displays <code>inst</code>.\nReturns an object that displays the given <code>value</code>’s …\nDynamic types created.\nExternal function references. These are functions that can …\nFacts: proof-carrying-code assertions about values.\nGet the first result of an instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if <code>inst</code> has any result values currently.\nStores large immediates that otherwise will not fit on …\nGet the instruction where the value was defined, if any.\nGet all value arguments on <code>inst</code> as a slice.\nGet all value arguments on <code>inst</code> as a mutable slice.\nGet the fixed value arguments on <code>inst</code> as a slice.\nGet the fixed value arguments on <code>inst</code> as a mutable slice.\nReturns <code>true</code> if the given instruction reference is valid.\nGet the result types of the given instruction.\nReturn all the results of an instruction.\nReturn all the results of an instruction as ValueList.\nConstruct a read-only visitor context for the values of …\nGet the variable value arguments on <code>inst</code> as a slice.\nGet the variable value arguments on <code>inst</code> as a mutable …\nData about all of the instructions in the function, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given block reference is valid.\nJump tables used in this function.\nGet the total number of basic blocks created in this …\nCreate a new basic block.\nDeclares a dynamic vector type\nCreate a new instruction.\nCreate result values for an instruction that produces …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate an invalid value, to pad the index space. This is …\nCreate a new value alias. This is only for use by the …\nMap a function over the values of the instruction.\nMerge the facts for two values. If both values have facts …\nCreate a new empty <code>DataFlowGraph</code>.\nGet the number component of this definition.\nGet the number of parameters on <code>block</code>.\nGet the total number of basic blocks created in this …\nGet the total number of instructions created in this …\nGet the total number of values.\nOverwrite the instruction’s value references with values …\nGet the parameters on <code>block</code>.\nRemoves <code>val</code> from <code>block</code>‘s parameters by a standard linear …\nCreate a <code>ReplaceBuilder</code> that will replace <code>inst</code> with a new …\nReplace a block parameter with a new value of type <code>ty</code>.\nReplace an instruction result with a new value of type …\nReplace the results of one instruction with aliases to the …\nResolve value aliases.\nReplace all uses of value aliases with their resolved …\nCompute the type of an alias. This is only for use in the …\nFunction signature table. These signatures are referenced …\nRemoves <code>val</code> from <code>block</code>’s parameters by swapping it with …\nCreate a union of two values.\nUnwrap the block there the parameter is defined, or panic.\nUnwrap the instruction where the value was defined, or …\nIf <code>v</code> is already defined as an alias, return its …\nGet the definition of a value.\nDetermine if <code>v</code> is an attached instruction result / block …\nCheck whether a value is valid and not an alias.\nCheck if a value reference is valid.\nCheck if a value reference is valid, while being aware of …\nMemory pool of value lists.\nGet the type of a value.\nGet an iterator over all values.\nGet an iterator over all values and their definitions.\nSaves Value labels.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nBase vector type, this is the minimum size of the type.\nConvert ‘base_vector_ty’ into a concrete dynamic …\nThe dynamic scaling factor of the base vector type.\nConvert a dynamic-vector type to a fixed-vector type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new dynamic type.\nAn opaque reference to any of the entities defined in this …\nAn opaque reference to a basic block in a <code>Function</code>.\na basic block.\nAn opaque reference to a constant.\nA constant.\nAn opaque reference to a dynamic stack slot.\nA dynamic stack slot.\nAn opaque reference to a dynamic type.\nA dynamic type\nAn opaque reference to another <code>Function</code>.\nAn external function.\nThe whole function.\nAn opaque reference to a global value.\nA Global value.\nAn opaque reference to an immediate.\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction.\nAn opaque reference to a jump table.\nA jump table.\nAn opaque reference to a memory type.\nA memory type.\nAn opaque reference to a function <code>Signature</code>.\nA function call signature.\nA function’s stack limit\nAn opaque reference to a stack slot.\nA stack slot.\nA reference to an <code>UserExternalName</code>, declared with …\nAn opaque reference to an SSA value.\nAn SSA value.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nCreate a new stack slot reference from its number.\nCreate a new stack slot reference from its number.\nCreate a new dynamic type reference from its number.\nCreate a new global value reference from its number.\nCreate a new memory type reference from its number.\nCreate a const reference from its number.\nCreate an immediate reference from its number.\nCreate a new jump table reference from its number.\nCreate a new external function reference from its number.\nCreate a new function signature reference from its number.\nWrapper type capable of displaying a <code>Function</code>.\nFunctions can be cloned, but it is not a very fast …\nFunction parameters used when creating this function, and …\nFunction fields needed when compiling a function.\nA version marker used to ensure that serialized clif ir is …\nReturns the base <code>SourceLoc</code>.\nClear all data structures in this function.\nStarts collection of debug information.\nCreates a dynamic stack slot in the function, to be used …\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nDeclares a memory type for use by the function.\nCreates a sized stack slot in the function, to be used by …\nDeclare a user-defined external function import, to be …\nData flow graph containing the primary definition of all …\nReturn an object that can display this function with …\nDynamic stack slots allocated in this function.\nSets the base <code>SourceLoc</code>, if not set yet, and returns the …\nRetrieve a <code>UserExternalNameRef</code> for the given name, or add …\nSize occupied by all stack slots associated with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a concrete <code>Type</code> from a user defined <code>DynamicType</code>.\nFind the global dyn_scale value associated with given …\nFind the global dyn_scale for the given stack slot.\nGlobal value proof-carrying-code facts.\nGlobal values referenced.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified block can be encoded as a basic …\nReturns true if the function is function that doesn’t …\nLayout of blocks and instructions in the function body.\nMemory types for proof-carrying code.\nName of this function.\nCreates a new <code>FunctionParameters</code> with the given name.\nCreate a new empty, anonymous function with a Fast calling …\nAll the parameters that can be applied onto the function …\nResets an already existing user function name to a new …\nRewrite the branch destination to <code>new_dest</code> if the …\nSets an absolute source location for the given instruction.\nSignature of this function.\nSized stack slots allocated in this function.\nFind a presumed unique special-purpose function parameter …\nReturns an absolute source location for the given …\nSource locations.\nAn optional global value which represents an expression …\nAll the fields required for compiling a function, …\nReplace the <code>dst</code> instruction’s data with the <code>src</code> …\nReturns the internal mapping of <code>UserExternalNameRef</code> to …\nA version marker used to ensure that serialized clif ir is …\nCreate a function with the given name and signature.\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvert a type into a vector of bytes; all implementors in …\n32-bit signed immediate offset.\nA 32-bit unsigned integer immediate operand.\n64-bit immediate unsigned integer operand.\n8-bit unsigned integer immediate operand.\nA 128-bit immediate operand.\nComputes the absolute value of self.\nComputes the absolute value of self.\nConverts Self to a rust f32\nConverts Self to a rust f64\nConvert the immediate into a slice.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nIterate over the bytes in the constant.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns a number composed of the magnitude of self and the …\nReturns a number composed of the magnitude of self and the …\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the little-endian byte representation of the …\nCheck if the value is a NaN.\nCheck if the value is a NaN. For Ieee64, this means …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self is positive or negative zero\nReturns true if self is positive or negative zero\nReturn self negated.\nReturn self negated.\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code>.\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nSign extend this immediate as if it were a signed integer …\nReturns the square root of self.\nReturns the square root of self.\nConvert the immediate into a vector.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nAdd in the signed number <code>x</code> if possible.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code> if …\nCreate a new <code>Ieee32</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nReturn self negated.\nReturn self negated.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\nA pair of a Block and its arguments, stored in a single …\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe operand is bound to a known type.\n<code>br_table x, JT</code>. (BranchTable)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\n<code>brif c, block_then, block_else</code>. (Brif) Type inferred from <code>c</code>…\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\nInformation about call instructions.\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\n<code>debugtrap</code>. (NullAry)\nThis is a direct call to an external function declared in …\nWrapper for the context needed to display a BlockCall …\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\nThe operand type can vary freely within the given set.\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\n<code>a = global_value GV</code>. (UnaryGlobalValue)\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = iadd_carry x, y, c_in</code>. (Ternary) Type inferred …\n<code>a = iadd_cin x, y, c_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nThis is an indirect call with the specified signature. See …\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn instruction format\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = is_invalid x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = is_null x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = isub_bin x, y, b_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, b_out = isub_borrow x, y, b_in</code>. (Ternary) Type inferred …\nJump(imms=(), vals=0, blocks=1)\n<code>jump block_call</code>. (Jump)\nLoad(imms=(flags: ir::MemFlags, offset: …\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\n<code>nop</code>. (NullAry)\nThis is not a call instruction.\n<code>a = null</code>. (NullAry)\nNullAry(imms=(), vals=0, blocks=0)\nAn instruction opcode.\nValue type constraints for a given opcode.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nThe type constraint on a value argument once the …\n<code>resumable_trap code</code>. (Trap)\n<code>resumable_trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>return rvals</code>. (MultiAry)\n<code>return_call FN, args</code>. (Call)\n<code>return_call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = sadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = smul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = ssub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\n<code>trap code</code>. (Trap)\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a, of = uadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = umul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = usub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\nA value type set describes the permitted set of types for …\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\n<code>a = x86_blendv c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = x86_cvtt2dq x</code>. (Unary)\n<code>a = x86_pmaddubsw x, y</code>. (Binary)\n<code>a = x86_pmulhrsw x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = x86_pshufb x, y</code>. (Binary)\nAll cranelift opcodes.\nReturn information about a call instruction.\nAppend an argument to the block args.\nReturn a slice for the arguments of this block.\nReturn a slice for the arguments of this block.\nGet the value arguments to this instruction.\nGet mutable references to the value arguments to this …\nIf this is an atomic read/modify/write instruction, return …\nReturn the block for this BlockCall.\nGet the destinations of this instruction, if it’s a …\nGet a mutable slice of the destinations of this …\nCan this instruction read from memory?\nCan this instruction write to memory?\nCan this instruction cause a trap?\nClear out the arguments list.\nIf this is a control-flow instruction depending on an …\nGet the constraint descriptor for this opcode. Panic if …\nDoes <code>typ</code> belong to this set?\nGet the typeset of allowed types for the controlling type …\nDeep-clone the underlying list in the same pool. The …\nDeep-clone an <code>InstructionData</code>, including any referenced …\nReturn a value that can display this block call.\nAllowed dynamic vectors minimum lane sizes\nCompare two <code>InstructionData</code> for equality.\nGet an example member of this type set.\nAppends multiple elements to the arguments.\nAllowed float widths\nGet the instruction format for this opcode.\nIf this is a control-flow instruction depending on a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Opcode name from a string.\nHash an <code>InstructionData</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this to a value list in <code>pool</code> with <code>fixed</code> prepended.\nAllowed int widths\nTrue for all branch or jump instructions.\nIs this a call instruction?\nCheck if the list is empty.\nIs this instruction polymorphic?\nReturns true if the instruction is a resumable trap.\nIs this a return instruction?\nTrue for instructions that terminate the block\nAllowed lane sizes\nIf this is a load/store instruction, returns its immediate …\nReplace the values used in this instruction according to …\nIf this is a load/store instruction, return its memory …\nConstruct a BlockCall with the given block and arguments.\nCreate an empty argument list.\nGet the number of <em>fixed</em> result values produced by this …\nGet the number of <em>fixed</em> input values required by this …\nGet the opcode of this instruction.\nDoes this instruction have other side effects besides can_*…\nAdd an argument to the end.\nAllowed ref widths\nRemove the argument at ix from the argument list.\nIs it necessary to look at the designated value input …\nGet the value type of result number <code>n</code>, having resolved the …\nReplace the block for this BlockCall.\nDespite having side effects, is this instruction okay to …\nIf this instruction references a stack slot, return it\nIf this is a trapping instruction, get its trap code. …\nIf this is a trapping instruction, get an exclusive …\nGet the controlling type variable operand.\nCan the controlling type variable for this opcode be …\nGet the value type of input value number <code>n</code>, having …\nA wrapper for the context required to display a …\nContents of a jump table.\nThe jump table and default block as a single slice. The …\nThe jump table and default block as a single mutable …\nAccess the jump table as a mutable slice. This excludes …\nAccess the jump table as a slice. This excludes the …\nClears all entries in this jump table, except for the …\nFetch the default block for this jump table.\nMutable access to the default block of this jump table.\nReturn a value that can display the contents of this jump …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator to the jump table, excluding the …\nReturns an iterator that allows modifying each value, …\nCreate a new jump table with the provided blocks.\nIterate over blocks in layout order. See …\nIterate over instructions in a block in layout order. See …\nThe <code>Layout</code> struct determines the layout of blocks and …\nInsert <code>block</code> as the last block in the layout.\nAppend <code>inst</code> to the end of <code>block</code>.\nReturns the capacity of the <code>BlockData</code> map.\nIterate over the instructions in <code>block</code> in layout order.\nReturn an iterator over all blocks in layout order.\nClear the layout.\nGet the function’s entry block. This is simply the first …\nFetch a block’s first instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert <code>block</code> in the layout before the existing block <code>before</code>…\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>inst</code> before the instruction <code>before</code> in the same …\nGet the block containing <code>inst</code>, or <code>None</code> if <code>inst</code> is not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> currently part of the layout?\nIs the given block cold?\nGet the last block in the layout.\nFetch a block’s last instruction.\nCreate a new empty <code>Layout</code>.\nGet the block following <code>block</code> in the layout order.\nFetch the instruction following <code>inst</code>.\nGet the block containing the program point <code>pp</code>. Panic if <code>pp</code> …\nCompare the program points <code>a</code> and <code>b</code> in the same block …\nGet the block preceding <code>block</code> in the layout order.\nFetch the instruction preceding <code>inst</code>.\nRemove <code>block</code> from the layout.\nRemove <code>inst</code> from the layout.\nMark a block as “cold”.\nSplit the block containing <code>before</code> in two.\nAccess to a field via the wrong type.\nThe base part of a bound expression.\nA comparison result between two dynamic values with a …\nA “conflict fact”: this fact results from merging two …\nA definition of a value to be used as a symbol in …\nA pointer to a memory type, dynamically bounded. The …\nA value bounded by a global value.\nContains the error value\nA bound expression.\nA fact on a value.\nA “context” in which we can evaluate and derive facts. …\nA global value.\nThe two kinds of inequalities: “strict” (<code>&lt;</code>, <code>&gt;</code>) and “…\nAccess to an invalid or undefined field offset in a struct.\nStore of data to a field with a fact that does not subsume …\nLoose inequality: {less,greater}-than-or-equal.\nTop of the address space. This is “saturating”: the …\nA pointer to a memory type.\nAn input to an operator that produces a fact-annotated …\nNo dynamic part (i.e., zero).\nContains the success value\nA memory access is out of bounds.\nAn operation wraps around, invalidating the stated value …\nAn error or inconsistency discovered when checking …\nThe result of checking proof-carrying-code facts.\nA bitslice of a value (up to a bitwidth) is within the …\nStrict inequality: {less,greater}-than.\nProof-carrying-code checking is not implemented for a …\nProof-carrying-code checking is not implemented for a …\nA block parameter claims a fact that one of its …\nA derivation of an output fact is unsupported (incorrect or\nAn SSA Value as a symbolic value. This can be referenced in\nStore to a read-only field.\nComputes whatever fact can be known about the sum of two …\nApply a known inequality to rewrite dynamic bounds using …\nIs this a constant value of the given bitwidth? Return it …\nIs this fact a single-value range with a symbolic Expr?\nThe dynamic (base) part.\nTop-level entry point after compilation: this checks the …\nCreate a range fact that specifies a single known constant …\nConstant value.\nCreate a dynamic range fact that points to the base of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a fact that specifies the value is exactly the …\nThe value of a global value.\nCreate a fact that specifies the value is exactly the …\nTry to infer a minimal fact for a value of the given IR …\nMerge two facts. We take the <em>intersection</em>: that is, we know\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes this dynamic_expression take an offset?\nCheck a load, and determine what fact, if any, the result …\nCreate a range fact that specifies the maximum range for a …\nCreate a range fact that specifies the maximum range for a …\nCreate a new “fact context” in which to evaluate facts.\nOffsets a value with a fact by a known amount.\nAdd a static offset to an expression.\nThe static (offset) part.\nDoes this fact “propagate” automatically, i.e., cause …\nScales a value with a fact by a known constant.\nComputes the <code>sextend</code> of a value with the given facts.\nLeft-shifts a value with a fact by a known constant.\nCheck a store.\nGet the access struct field, if any, by a pointer with the …\nComputes whether <code>lhs</code> “subsumes” (implies) <code>rhs</code>.\nComputes whether the optional fact <code>lhs</code> subsumes (implies) …\nComputes the bit-truncation of a value with the given fact.\nComputes the <code>uextend</code> of a value with the given facts.\nCompute the union of two facts, if possible.\nCreate a fact that specifies the value is exactly an SSA …\nThe value of an SSA value.\nCreate a fact that specifies the value is exactly an SSA …\nIs this Expr a BaseExpr with no offset? Return it if so.\nThe bitwidth of bits we care about, from the LSB upward.\nThe bitwidth of bits we care about, from the LSB upward.\nThe kind of comparison.\nThe left-hand side of the comparison.\nThe maximum value that the bitslice can take (inclusive). …\nThe upper bound, inclusive.\nThe upper bound, inclusive.\nThe maximum offset into the memory type, inclusive.\nThe minimum value that the bitslice can take (inclusive). …\nThe lower bound, inclusive.\nThe lower bound, inclusive.\nThe minimum offset into the memory type, inclusive.\nThis pointer can also be null.\nThis pointer can also be null.\nThe right-hand side of the comparison.\nThe memory type.\nThe memory type.\nThe SSA value this value defines.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nThe size of an object on the stack, or the size of a stack …\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nAlignment of stack slot as a power-of-two exponent (log2 …\nGet the alignment in bytes of this stack slot given the …\nThe type of this slot.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of stack slot.\nThe kind of stack slot.\nCreate a stack slot with the specified byte size and …\nCreate a stack slot with the specified byte size.\nSize of stack slot in bytes.\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nAn opaque reference type with 32 bits.\nAn opaque reference type with 64 bits.\nThe type of an SSA value.\nGet a type with the same number of lanes as this type, but …\nGet the type of a comparison result for the given type. …\nGet a type with the same number of lanes as this type, but …\nGet the total number of bits used to represent this type.\nGet the (minimum, maximum) values represented by each lane …\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nGet a type with the same number of lanes as this type, but …\nConvert a dynamic vector type to a fixed one.\nReturns the argument unchanged.\nGet a type with the same number of lanes as this type, but …\nIndex of this type, for use with hash tables etc.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nIs this the INVALID type?\nIs this a lane type?\nIs this a ref type?\nIs this a special type?\nIs this a SIMD vector type?\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nSplit the lane width in half and double the number of …\nReturn the pointer type for the given target triple.\nConvert a fixed vector type to a dynamic one.\nTrue iff:\nThe string names of all the supported, but possibly not …\nMac aarch64 calling convention, which is a tweaked aarch64 …\nType alias of <code>IsaBuilder</code> used for building Cranelift’s …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nFunction alignment specifications as required by an ISA, …\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nThe type of a polymorphic TargetISA object which is ’…\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nSupports tail calls, not ABI-stable.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nWasmtime equivalent of SystemV, not ABI-stable.\nThe winch calling convention, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nARM 64-bit Instruction Set Architecture.\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nIs the calling convention extending the Apple aarch64 ABI?\nIs the calling convention extending the Windows Fastcall …\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new Builder from a TargetIsa, copying all flags …\nGet the information needed by frontends producing …\nReturns the minimum function alignment and the preferred …\nReturns whether this ISA has a native …\nReturns whether the CLIF <code>x86_blendv</code> instruction is …\nReturns whether the CLIF <code>x86_pmaddubsw</code> instruction is …\nReturns whether the CLIF <code>x86_pmulhrsw</code> instruction is …\nReturns whether the CLIF <code>x86_pshufb</code> instruction is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nMap a regalloc::Reg to its corresponding DWARF register.\nThe minimum alignment required by an ISA, where all …\nGet the name of this ISA.\nCreates a new ISA-builder from its components, namely the …\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nA “preferred” alignment which should be used for more …\nrisc-v 64-bit Instruction Set Architecture.\nDoes this calling convention support tail calls?\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGenerate a <code>Capstone</code> context for disassembling bytecode for …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nRepresents information relating to function unwinding.\nCreate a polymorphic TargetIsa from this specific …\nX86_64-bit Instruction Set Architecture.\nAn AArch64 backend.\nReturns the argument unchanged.\nThis module defines aarch64-specific machine instruction …\nCalls <code>U::from(self)</code>.\nCreate a new <code>isa::Builder</code>.\nCreate a new AArch64 backend with the given (shared) flags.\nAArch64 Settings.\nInternal type ALUOp: defined at src/isa/aarch64/inst.isle …\nInternal type ALUOp3: defined at src/isa/aarch64/inst.isle …\nInternal type AMode: defined at src/isa/aarch64/inst.isle …\nInternal type APIKey: defined at src/isa/aarch64/inst.isle …\n21-bit offset for ADR (get address of label). PC-rel, …\nInternal type AtomicRMWLoopOp: defined at …\nInternal type AtomicRMWOp: defined at …\nInternal type BitOp: defined at src/isa/aarch64/inst.isle …\n14-bit branch offset (conditional branches). PC-rel, …\n19-bit branch offset (conditional branches). PC-rel, …\n26-bit branch offset (unconditional branches). PC-rel, …\nInternal type BranchTargetType: defined at …\nAdditional information for CallInd instructions, left out …\nAdditional information for (direct) Call instructions, …\nInternal type FPUOp1: defined at src/isa/aarch64/inst.isle …\nInternal type FPUOp2: defined at src/isa/aarch64/inst.isle …\nInternal type FPUOp3: defined at src/isa/aarch64/inst.isle …\nA floating-point unit (FPU) operation with two args, a …\nA floating-point unit (FPU) operation with two args, a …\nInternal type FpuRoundMode: defined at …\nInternal type FpuToIntOp: defined at …\nInternal type MInst: defined at src/isa/aarch64/inst.isle …\nInternal type IntToFpuOp: defined at …\nDifferent forms of label references for different …\n19-bit offset for LDR (load literal). PC-rel, offset is …\nInternal type MoveWideOp: defined at …\n32-bit PC relative constant offset (from address of …\nAdditional information for <code>return_call[_ind]</code> instructions, …\nShift left and insert. Rd |= Rn &lt;&lt; #imm\nShift left and insert. Rd |= Rn &lt;&lt; #imm\nUnsigned right shift. Rd = Rn &lt;&lt; #imm\nUnsigned right shift. Rd = Rn &lt;&lt; #imm\nInternal type VecALUModOp: defined at …\nInternal type VecALUOp: defined at …\nInternal type VecExtendOp: defined at …\nInternal type VecLanesOp: defined at …\nInternal type VecMisc2: defined at …\nInternal type VecPairOp: defined at …\nInternal type VecRRLongOp: defined at …\nInternal type VecRRNarrowOp: defined at …\nInternal type VecRRPairLongOp: defined at …\nInternal type VecRRRLongModOp: defined at …\nInternal type VecRRRLongOp: defined at …\nInternal type VecShiftImmModOp: defined at …\nInternal type VecShiftImmOp: defined at …\nAArch64 ISA definitions: instruction arguments.\nCallee calling convention.\nCallee calling convention.\nThe number of bytes that the callee will pop from the …\nThe number of bytes that the callee will pop from the …\nCaller calling convention.\nCaller calling convention.\nClobbers register set.\nClobbers register set.\nReturn values from the call instruction.\nReturn values from the call instruction.\nCall destination.\nAArch64 ISA: binary code emission.\nReturns the encoding of the <code>auti{key}</code> instruction used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGeneric constructor for a load (zero-extending where …\nGeneric constructor for a store.\nAArch64 ISA definitions: immediate constants.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAPI key to use to restore the return address, if any.\nCreate an instruction that loads a constant, using one of …\nWhat type does this load or store instruction access in …\nThe size of the new stack frame’s stack arguments. This …\nGet the assembly mnemonic for this opcode.\nInstruction opcode.\nInstruction opcode.\nInstruction opcode.\nMemory reference using an address in a register.\nMemory reference using <code>reg1 + sizeof(ty) * reg2</code> as an …\nFunction pointer for indirect call.\nArguments to the call instruction.\nArguments to the call instruction.\nArguments to the call instruction.\nArithmetic shift right.\nAlways executed.\nA branch target. Either unresolved (basic-block index) or …\nCondition for conditional branches.\nCondition: the given condition-code test is true.\nThe kind of conditional branch: the common-case-optimized …\nEqual.\nAn extend operator for a register.\nSigned greater or equal to.\nSigned greater than.\nUnsigned greater than.\nUnsigned greater than or equal to.\nLogical shift left.\nLogical shift right.\nAn unresolved reference to a Label, as passed into …\nSigned less than or equal.\nUnsigned less than.\nUnsigned less than or equal to.\nSigned less than.\nMaximum shift for shifted-register operands.\nAn address that refers to a label within a <code>MachBuffer</code>, for …\nA reference to some memory address.\nMinus, negative.\nNot equal.\nCondition: given register is nonzero.\nAlways executed.\nType used to communicate the operand size of a machine …\nAn address in the code, a constant pool or jumptable, with …\nInternal type PairAMode: defined at …\nPositive or zero.\nRotate right.\nA fixed PC offset.\nSigned extend byte.\nSigned extend halfword.\nSigned extend word.\nSigned extend doubleword.\nType used to communicate the size of a scalar SIMD &amp; FP …\nA shift operator for a register or immediate.\nA shift operator with an amount, guaranteed to be within …\nA shift operator amount.\n128-bit.\n16-bit.\n16-bit, 4 lanes.\n16-bit, 8 lanes.\n32-bit.\n32-bit.\n32-bit, 2 lanes.\n32-bit, 4 lanes.\n64-bit.\n64-bit.\n64-bit, 2 lanes.\n8-bit.\n8 bit, 16 lanes.\n8-bit, 8 lanes.\nInternal type TestBitAndBranchKind: defined at …\nUnsigned extend byte.\nUnsigned extend halfword.\nUnsigned extend word.\nUnsigned extend doubleword.\nNo signed overflow.\nType used to communicate the size of a vector operand.\nSigned overflow.\nCondition: given register is zero.\nGet the shift amount.\nReturn the target’s label, if it is a label-based target.\nReturn the target’s offset, if specified, or zero if …\nReturn the target’s offset, if specified, or zero if …\nReturn the target’s offset, if specified, or zero if …\nGet the encoding of this shift op.\nEncoding of this op.\nReturn the machine encoding of this condition.\nReturn the operand size in bits.\nComplements this branch condition to act on the opposite …\nReturn the encoding bit that is used by some …\nReturn the encoding bits that are used by some SIMD …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a needed width to the smallest size that fits.\nGet the vector operand size with the given scalar size as …\nConvert from an integer type into the smallest size that …\nReturn the encoding bits that are used by some scalar FP …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the inverted condition.\nReturn the inverted branch condition.\n32-bit case?\n64-bit case?\nReturns true if the VectorSize is 128-bits.\nGet the scalar operand size that corresponds to a lane of …\nMask down to a given number of bits.\nThe maximum unsigned value representable in a value of …\nCreate a new shiftop shift amount, if possible.\nReturn the narrowed version of the scalar size.\nCreate a new shift operator with an amount.\nGet the shift op.\nConvert to an integer operand size.\nGet the integer operand size that corresponds to a lane of …\nRegister interpretation bit. When 0, the register is …\nConvert to I32, I64, or I128.\nReturn a type with the same size as this scalar.\nReturn the shift amount.\nReturn the widened version of the scalar size.\nConstant state used during function compilation.\nState carried between emissions of a sequence of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMemory addressing mode finalization: convert “special” …\nCreate a constant state for emission of instructions.\nAdvanced SIMD modified immediate as used by the vector …\nAdvanced SIMD modified immediate as used by MOVI/MVNI.\nFloating-point unit immediate left shift.\nFloating-point unit immediate right shift.\nA shifted immediate value in ‘imm12’ format: supports …\nAn immediate for logical instructions.\nAn immediate for shift instructions.\nA 16-bit immediate for a MOVZ instruction, with a …\nAn immediate that represents the NZCV flags.\nA signed, scaled 7-bit offset.\na 9-bit signed offset.\nAn unsigned, scaled 12-bit offset.\nAn unsigned 5-bit immediate.\nShift amount.\nShift amount.\nBits for encoding.\nBits for encoding.\nBits for encoding.\nBits for encoding.\nEncoded bits.\nThe immediate bits.\nThe value.\nReturns the encoding of the immediate.\nReturns encoding of the immediate.\nReturns bits ready for encoding: (N:1, R:6, S:6)\nReturns bits ready for encoding.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n6-bit shift amount.\nBits for 12-bit “imm” field in e.g. AddI.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an immediate for the bitwise-inverted value.\nLane size in bits.\nLane size in bits.\nCreate a SImm7Scaled from a raw offset and the known scale …\nCreate a signed 9-bit offset from a full-range value, if …\nCreate a UImm12Scaled from a raw offset and the known …\nCompute a Imm12 from raw bits, if possible.\nCompute an ImmLogic from raw bits, if possible.\nCreate an ImmShift from raw bits, if possible.\nConstruct a MoveWideConst from an arbitrary 64-bit …\nConstruct an ASIMDMovModImm from an arbitrary 64-bit …\nConstruct an ASIMDFPModImm from an arbitrary 64-bit …\nCreate an unsigned 5-bit immediate from u8.\nCreate a floating-point unit immediate left shift from u8.\nCreate a floating-point unit immediate right shift from u8.\nCreate a <code>MoveWideCosnt</code> from a given shift, if possible.\n<code>N</code> flag.\nCreate a new NZCV flags representation.\n<code>S</code> field: element size and element bits.\n<code>R</code> field: rotate amount.\nmultiplied by the size of this type\nResult is <code>bits</code> shifted 16*shift bits to the left.\nWhether the immediate bits are shifted left by 12 or not.\nBits for 2-bit “shift” field in e.g. AddI.\nWas this constructed for a 32-bit or 64-bit instruction?\nSigned value of immediate.\nValue after scaling.\nGet the actual value that this immediate corresponds to.\nReturns the value that this immediate represents.\nGet the immediate value.\nReturns the value that this immediate represents.\nThe value.\nThe value.\nCreate a zero immediate of this format.\nCreate a zero immediate of this format.\nCreate a zero immediate of this format.\nFlags group <code>arm64</code>.\nCreate a <code>settings::Builder</code> for the arm64 settings group.\nReturns the argument unchanged.\nHas Large System Extensions (FEAT_LSE) support.\nHas Pointer authentication (FEAT_PAuth) support; enables …\nCalls <code>U::from(self)</code>.\nIterates the setting values.\nCreate flags arm64 settings group.\nGet a view of the boolean predicates.\nUse pointer authentication instructions to sign function …\nIf function return address signing is enabled, then apply …\nUse the B key with pointer authentication instructions …\nUse Branch Target Identification (FEAT_BTI) instructions.\nAn riscv64 backend.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>isa::Builder</code>.\nCreate a new riscv64 backend with the given (shared) flags.\nDefines if the aarch64-specific pointer authentication …\nCFA-based unwind information used on SystemV.\nThe frame-pointer register for this architecture has just …\nNo unwind info.\nThe frame-pointer register for this architecture has just …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystemV CIE/FDE unwind info.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nExpected unwind info type.\nUnwind pseudoinstruction used in VCode backends: …\nWindows X64 Unwind info\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOut-of-line data for calls, to keep the size of <code>Inst</code> down.\nConstant state used during emissions of a sequence of …\nState carried between emissions of a sequence of …\nInternal type MInst: defined at src/isa/x64/inst.isle line …\nInstruction operand sub-components (aka “parts”): …\nThe calling convention of the callee.\nThe number of bytes that the callee will pop from the …\nRegisters clobbered by this call, as per its calling …\nCreates a new x86-64 common information entry (CIE).\nRegister defs of this call.\nEmit unwind info for an x86 target.\nContains the encoding machinery for the various x64 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a constant state for emission of instructions.\nx86 Settings.\nRegister uses of this call.\nAdd with carry.\nAdd operation.\nInternal type AluRmROpcode: defined at …\nSome basic ALU operations.\nInternal type Amode: defined at src/isa/x64/inst.isle line …\nBitwise AND operation.\nInternal type Avx512Opcode: defined at …\nInternal type AvxOpcode: defined at src/isa/x64/inst.isle …\n&lt; unsigned\n&lt;= unsigned\nByte -&gt; Longword.\nByte -&gt; Quadword.\nBit-scan forward.\nBit-scan reverse.\nThese indicate condition code tests.  Not all are …\nCMP instruction: compute <code>a - b</code> and set flags from result.\nComparison operations.\nA virtual offset to a constant that will be emitted in the …\nInternal type DivSignedness: defined at …\nEqual comparison.\nThis defines the ways a value can be extended: either …\nThese indicate ways of extending (widening) a value, using …\nEncode the ways that floats can be compared. This is used …\nAn x64 memory fence kind.\nAn extension trait for converting <code>Writable&lt;Reg&gt;</code> to …\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nAn immediate operand.\n8-bit immediate operand.\nA newtype wrapper around <code>Imm8Reg</code>.\nAn operand which is either an 8-bit integer immediate or a …\nA newtype wrapper around <code>Imm8Reg</code>.\nA (virtual) offset into the incoming argument area.\n&lt; signed\n&lt;= signed\n<code>lfence</code> instruction (“Load Fence”)\nLongword -&gt; Quadword.\nLess than comparison.\nLess than or equal comparison.\nCounts leading zeroes (Leading Zero CouNT).")