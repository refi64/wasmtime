searchState.loadedDescShard("cranelift_isle", 0, "ISLE: Instruction Selection / Lowering Expressions\nAbstract syntax tree (AST) created from parsed ISLE.\nGenerate Rust code from a series of Sequences.\nCompilation process, from AST to Sema to Sequences of …\nImplementation of <code>DisjointSets</code>, to store disjoint sets and …\nError types.\nLexer for the ISLE language.\nLog a compiler-internal message for debugging purposes.\nOverlap detection for rules in ISLE.\nParser for ISLE language.\nSemantic analysis.\nPut “sea of nodes” representation of a <code>RuleSet</code> into a …\nImplementations of hashmap and hashset that asvoid …\nA strongly-normalizing intermediate representation for …\nN sub-patterns that must all match.\nAn operator that binds a variable to a subterm and matches …\nAn external constant: <code>(const $IDENT type)</code> form.\nAn operator that matches a constant integer value.\nA constant integer.\nAn operator that matches an external constant value.\nA constant of some other primitive type.\nAn external constructor: <code>(constructor Term rustfunc)</code> form.\nAn implicit converter: the given term, which must have type\nA declaration of a term with its argument and return types.\nOne toplevel form in an ISLE file.\nThe parsed form of an ISLE file.\nAn expression: the right-hand side of a rule.\nAn external binding: an extractor or constructor function …\nAn extractor macro: (A x y) becomes (B x _ y …). …\nAn external extractor: <code>(extractor Term rustfunc)</code> form.\nOne field of an enum variant.\nAn identifier – a variable, term symbol, or type.\nThe <code>(let ((var ty val)*) body)</code> form.\nOne variable locally bound in a <code>(let ...)</code> expression.\nInternal use only: macro argument in a template.\nA pattern: the left-hand side of a rule.\nPragmas parsed with the <code>(pragma &lt;ident&gt;)</code> syntax.\nAn application of a type variant or term.\nA term: <code>(sym args...)</code>.\nA declaration of a type.\nThe actual type-value: a primitive or an enum with …\nA mention of a variable.\nA variable use.\nOne variant of an enum type.\nAn operator that matches anything.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe “inner type”: the type to convert <em>from</em>, on the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this term can exist with some multiplicity: an …\nThe “outer type”: the type to convert <em>to</em>, on the …\nWhether this term’s constructor can fail to match.\nThe position of this converter decl.\nWhether this term’s constructor is pure.\nThe term name.\nCall <code>f</code> for each of the terms in this pattern.\nCall <code>f</code> for each of the terms in this expression.\nThe Rust function name.\nThe Rust function name.\nInfallibility: if an external extractor returns …\nThe position of this decl.\nThe position of this decl.\nThe term to which this external extractor is attached.\nThe term to which this external constructor is attached.\nOptions for code generation.\nEmit Rust source code for the given type and term …\nDo not include the <code>#![allow(...)]</code> pragmas in the generated …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompile the given AST definitions into Rust source code.\nCompile the given files into Rust source code.\nStores disjoint sets and provides efficient operations to …\nFind a representative member of the set containing <code>x</code>. If <code>x</code> …\nFind a representative member of the set containing <code>x</code>. If <code>x</code> …\nReturns the argument unchanged.\nReturns whether the given items have both been merged into …\nCalls <code>U::from(self)</code>.\nReturns true if there are no sets. This method takes …\nReturns the total number of elements in all sets. This …\nMerge the set containing <code>x</code> with the set containing <code>y</code>. This …\nRemove the set containing the given item, and return all …\nErrors produced by ISLE.\nA collection of errors from attempting to compile some …\nAn I/O error.\nThe rules mentioned overlap in the input they accept.\nThe input ISLE source has a parse error.\nThe rules can never match because another rule will always …\nA span in a given source.\nThe input ISLE source has a type error.\nThe rule can never match any input.\nThe individual errors.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe byte offset of the start of the span.\nCreate <code>isle::Errors</code> from the given I/O error and context.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new span that covers one character at the given …\nThe byte offset of the end of the span.\nThe context explaining what caused the I/O error.\nThe underlying I/O error.\nThe location of the rule that shadows them.\nThe error message.\nThe error message.\nThe error message.\nThe error message.\nThe locations of all the rules that overlap. When there …\nThe locations of the unmatchable rules.\nThe location of the parse error.\nThe location of the type error.\nThe location of the unreachable rule.\n<code>@</code>\nAn integer.\nLeft paren.\nThe lexer.\nA source position.\nRight paren.\nA symbol, e.g. <code>Foo</code>.\nA token of ISLE source.\nThis source position’s column number in the file.\nAre we at the end of the source input?\nThis source position’s file.\nArena of file source texts.\nArena of filenames from the input source.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new lexer from the given files and contents.\nCreate a new lexer from the given files.\nCreate a new lexer for the given source contents and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this an <code>Int</code> token?\nIs this a <code>Sym</code> token?\nThis source position’s line number in the file.\nGet the next token from this lexer’s token stream, if …\nThis source position’s byte offset in the file.\nPeek ahead at the next token.\nGet the lexer’s current source position.\nPrint this source position as <code>file.isle line 12</code>.\nCheck for overlap.\nParse the top-level ISLE definitions and return their AST.\nMatch all of the following patterns of the given type.\nBind a variable of the given type from the current value.\nA name bound in a pattern or let-expression.\nMatch the current value against a constant integer of the …\nGet a constant integer.\nMatch the current value against a constant primitive value …\nGet a constant primitive.\nThe kind of a constructor for a term.\nA term declared via a <code>(decl ...)</code> form.\nA sum type.\nAn enum variant constructor or extractor.\nA right-hand side expression of some rule.\nThe type returned from RuleVisitor::add_expr, which may be …\nThe type of subexpression identifiers.\nVisitor interface for Exprs. Visitors can return an …\nThe type of expression visitors constructed by …\nA term defined solely by an external constructor function.\nA term defined solely by an external extractor function.\nAn external function signature.\nThe kind of an extractor for a term.\nA field of a <code>Variant</code>.\nThe id of a field inside a variant.\nAn <code>if-let</code> clause with a subpattern match on an expr after …\nA term with “internal” rules that work in the forward …\nA term that defines an “extractor macro” in the LHS of …\nZero or more return values.\nEvaluate the nested expressions and bind their results to …\nZero or one return values.\nA left-hand side pattern of some rule.\nThe type of subpattern identifiers.\nVisitor interface for Patterns. Visitors can assign an …\nThe type of pattern visitors constructed by …\nExactly one return value.\nA primitive, <code>Copy</code> type.\nHow many values a function can return.\nA term rewrite rule.\nThe id of an interned rule inside the <code>TermEnv</code>.\nVisitor interface for Rules. Visitors must be able to …\nThe id of an interned symbol.\nA term.\nMatch the current value against the given extractor term …\nInvoke this term constructor with the given arguments.\nThe term environment.\nFlags from a term’s declaration with <code>(decl ...)</code>.\nThe id of an interned term inside the <code>TermEnv</code>.\nThe kind of a term.\nA type.\nThe type environment.\nThe id of an interned type inside the <code>TypeEnv</code>.\nMatch the current value against an already bound variable …\nGet the value of a variable that was bound in the …\nThe id of a bound variable inside a <code>Bindings</code>.\nA variant of an enum.\nThe id of a variant inside an enum.\nInformation about an expression after it has been fully …\nMatch anything of the given type successfully.\nVisit one of the arguments to the top-level pattern.\nConstruct a constant integer.\nConstruct a primitive constant.\nCall an external constructor with the given <code>inputs</code> as …\nConstruct an enum variant with the given <code>inputs</code> assigned …\nVisit an expression, used once for each if-let and once …\nMatch if the given external extractor succeeds on <code>input</code>. …\nMatch if <code>a</code> and <code>b</code> have equal values.\nMatch if <code>input</code> is the given integer constant.\nMatch if <code>input</code> is the given primitive constant.\nMatch if <code>input</code> is the given enum variant. Returns an …\nVisit a pattern, used once for the rule’s left-hand side …\nThe parameter types to this term.\nPatterns to test against the root term’s arguments.\nThe types of constant symbols.\nGet this term’s constructor’s external function …\nMap from (inner_ty, outer_ty) pairs to term IDs, giving the\nThe source position where this term was declared.\nType errors that we’ve found so far during type checking.\nGiven an expression from RuleVisitor::add_expr, return an …\nGet this term’s extractor’s external function …\nThe data fields of this enum variant.\nArena of input ISLE source contents.\nArena of input ISLE source filenames.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct the type environment from the AST.\nConstruct the term environment from the AST and the type …\nThe name of the external function, prefixed with the …\nThe full, prefixed-with-the-enum’s-name name of this …\nThe name of the external function.\nDoes this term have a constructor?\nIs this term’s constructor external?\nIs this term’s extractor external?\nDoes this term have an extractor?\nThe id of this variant, i.e. the index of this variant …\nThis field’s id.\nThis term’s id.\nThis rule’s id.\nThe identifier used for this variable within the scope of …\nAny subpattern “if-let” clauses.\nGet the index of this id.\nGet the index of this id.\nGet the index of this id.\nGet the index of this id.\nGet the index of this id.\nGet the index of this id.\nGet the index of this id.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this term an enum variant?\nIs this a primitive type?\nThe kind of this term.\nThe left-hand side pattern that this <code>if-let</code> clause matches …\nWhether the term is marked as <code>multi</code>.\nGet the name of this <code>Type</code>.\nThe name of this variant.\nThe name of this field.\nThe name of this term.\nThe variable’s name.\nThe types of this function signature’s parameters.\nWhether the term is marked as <code>partial</code>.\nGiven an identifier from the pattern visitor, return an …\nGet the position where this type was defined.\nThe source position where this rule is defined.\nThe priority of this rule, defaulted to 0 if it was …\nWhether the term is marked as <code>pure</code>.\nHow many values can this function return?\nThe result types of this term.\nThe types of this function signature’s results.\nThe right-hand side expression that this rule evaluates …\nThe right-hand side expression that this pattern …\nThe left-hand side pattern that this rule matches.\nArena of interned rules defined in this ISLE program.\nMap of already-interned symbol names to their <code>Sym</code> ids.\nArena of interned symbol names.\nA map from am interned <code>Term</code>’s name to its <code>TermId</code>.\nArena of interned terms defined in this ISLE program.\nGet this term’s type.\nGet this pattern’s type.\nGet this expression’s type.\nThe type of this field.\nThe type of the value this variable is bound to.\nThe type of the top-level expression.\nA map from a type name symbol to its <code>TypeId</code>.\nArena of type definitions.\nThe identifier returned by the visitor for the top-level …\nVariable names used in this rule, indexed by VarId.\nRecursively visit every pattern and expression in this …\nRecursively visit every sub-pattern.\nRecursively visit every subexpression.\nThe external name of the constructor function.\nThe expressions that are evaluated and bound to the given …\nThe body expression that is evaluated after the bindings.\nThe type of the result of this let expression.\nIs the external extractor infallible?\nThe external name of the extractor function.\nThe position where this external extractor was declared.\nThis extractor’s pattern.\nThe kind of this term’s constructor, if any.\nThe kind of this term’s extractor, if any.\nFlags from the term’s declaration.\nWhich variant of the enum: e.g. for enum type <code>A</code> if a term …\nThis <code>enum</code>’s type id.\nIs this <code>enum</code> defined in external Rust code?\nWhether this type should <em>not</em> derive <code>Debug</code>.\nThe name of this enum.\nThe ISLE source position where this <code>enum</code> is defined.\nThe different variants for this enum.\nA sequence of steps to evaluate in order. Any step may …\nWhat kind of control-flow structure do we need to emit …\nTest whether two binding sites have values which are equal …\nA step to evaluate involves possibly let-binding some …\nEvaluate a block once with each value of the given binding …\nTest a binding site against one or more mutually-exclusive …\nOne concrete pattern and the block to evaluate if the …\nReturn a result from the right-hand side of a rule. If we…\nBefore evaluating this case, emit let-bindings in this …\nIf this pattern matches, it brings these bindings into …\nSteps to evaluate if the pattern matched.\nThe control-flow construct to execute at this point.\nThe pattern to match.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecomposes the rule-set into a tree of Blocks.\nSteps to evaluate.\nOne binding site.\nWhat patterns do we care about?\nThe other binding site. To ensure we always generate the …\nIf the test succeeds, evaluate this block.\nWhat to evaluate with each binding.\nWhere was the rule defined that had this right-hand side?\nA binding site of type Binding::Iterator. Its source …\nWhat is the result expression which should be returned if …\nWhich binding site are we examining at this point?\nA wrapper around a HashMap which prevents accidentally …\nA wrapper around a HashSet which prevents accidentally …\nReturns true if the set contains a value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a value to the set. Returns whether the value was …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOne of the arguments to the top-level function.\nBindings are anything which can be bound to a variable …\nA hash-consed identifier for a binding, stored in a RuleSet…\nEvaluates to the given integer literal.\nThe value must equal this integer literal.\nEvaluates to the given primitive Rust value.\nThe value must equal this Rust primitive value.\nPattern matches which can fail. Some binding sites are the …\nThe result of calling an external constructor.\nThe result of calling an external extractor.\nThe result of getting one value from a multi-constructor …\nThe result of constructing an enum variant.\nPattern-match one of the previous bindings against …\nPattern-match one of the previous bindings against a tuple …\nPattern-match one of the previous bindings against an enum …\nThere is no input on which this pair of rules can both …\nRecords whether a given pair of rules can both match on …\nA term-rewriting rule. All BindingIds are only meaningful …\nA collection of Rules, along with hash-consed Bindings for …\nThe value must be an <code>Option::Some</code>, from a fallible …\nA field index in a tuple or an enum variant.\nThe value must match this enum variant.\nThere is at least one input on which this pair of rules …\nThe bindings identified by BindingIds within rules.\nReturn the nested Bindings from matching the given …\nConstruct a RuleSet for each term in <code>termenv</code> that has …\nSets of bindings which must be equal for this rule to …\nReturns the BindingId corresponding to the given Binding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the constraint that the given binding site must …\nIf this rule applies, these side effects should be …\nGet the index of this field.\nGet the index of this id.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThese bindings are from multi-terms which need to be …\nReturns whether a given pair of rules can both match on …\nWhere was this rule defined?\nIf other rules apply along with this one, the one with the …\nIf this rule applies, the top-level term should evaluate …\nThe Rules for a single sema::Term.\nReturns the binding sites which must be evaluated before …\nReturns the total number of binding sites which this rule …\nWhich field of this enum variant are we projecting out? …\nWhich tuple field are we projecting out?\nWhat expressions should be provided for this variant’s …\nWhich of the function’s arguments is this?\nFor impure constructors, a unique number for each use of …\nWhat expression should be passed to the extractor?\nWhat expressions should be passed to the constructor?\nWhich expression produced the iterator that this consumes?\nWhich binding is being matched?\nWhich binding is being matched?\nWhich binding is being matched?\nWhich extractor should be called?\nWhich constructor should be called?\nThe constant’s type. Unsigned types preserve the …\nWhich enum type should be constructed?\nThe constant value.\nThe constant value.\nWhich variant of that enum should be constructed?\nWhich enum variant are we pulling binding sites from? This …\nNumber of fields in this variant of this enum. This is …\nWhich enum type is being matched? This is implied by the …\nThe constant’s type. Unsigned types preserve the …\nThe constant value.\nThe constant value.\nWhich enum variant must this binding site match to satisfy …\nTrue if every input accepted by one rule is also accepted …")