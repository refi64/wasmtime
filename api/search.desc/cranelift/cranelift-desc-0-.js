searchState.loadedDescShard("cranelift", 0, "Cranelift umbrella crate, providing a convenient one-line …\nVersion number of this crate.\nProvide these crates, renamed to reduce stutter.\nA prelude providing convenient access to commonly-used …\nFunction parameter or return value descriptor.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nFailed float-to-int conversion.\nSignature mismatch on indirect call.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nAn opaque reference to a basic block in a <code>Function</code>.\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nA string-based configurator for settings groups.\nValue is a multiple of how many instances of <code>vector_type</code> …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nA type wrapping a small integer index should implement …\n<code>==</code>.\nEQ\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nAn external function.\nThe name of an external is either a reference to a …\nCondition code for comparing floating point numbers.\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nTemporary object used to build a single Cranelift IR …\nStructure used for translating a series of functions into …\nInformation about a global value declaration.\nGT\nGT | EQ\nA wasm atomic operation was presented with a …\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nValue is an offset from another global value.\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nIndirect call to a null table entry.\nConvenience methods for building instructions.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nCondition code for comparing integers.\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nExecution has potentially run too long and may be …\nJump(imms=(), vals=0, blocks=1)\nContents of a jump table.\nA well-known symbol.\nLT\nLT | EQ\nA well-known runtime library function.\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nFlags for memory operations like load/store.\nMultiAry(imms=(), vals=0, blocks=0)\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nNullAry(imms=(), vals=0, blocks=0)\nA null <code>i31ref</code> was encountered which was required to be …\nA null reference was encountered which was required to be …\nEQ | LT | GT\nLT | GT\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nFunction signature.\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nThe current stack space was exhausted.\nContents of a stack slot.\nThe kind of a stack slot.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nValue is symbolic, meaning it’s a name which will be …\nA <code>table_addr</code> instruction detected an out-of-bounds error.\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nA trap code describing the reason for a trap.\nThe type of an SSA value.\n64-bit immediate unsigned integer operand.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nCode that was supposed to have been unreachable was …\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nA reference to a name in a user-defined symbol table.\nA user-defined trap code.\nValue is the address of the VM context struct.\nAn opaque reference to an SSA value.\nAn opaque reference to a variable.\nComputes the absolute value of self.\nComputes the absolute value of self.\nReads the alias region that this memory operation works …\nAlignment of stack slot as a power-of-two exponent (log2 …\nTest if the <code>aligned</code> flag is set.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nThe jump table and default block as a single slice. The …\nThe jump table and default block as a single mutable …\nCreates a parameter for a specific <code>Block</code> by appending it …\nAppend parameters to the given <code>Block</code> corresponding to the …\nAppend parameters to the given <code>Block</code> corresponding to the …\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nConverts Self to a rust f32\nConverts Self to a rust f64\nGet a type with the same number of lanes as this type, but …\nAccess the jump table as a mutable slice. This excludes …\nAccess the jump table as a slice. This excludes the …\nGet the type of a comparison result for the given type. …\nGet a type with the same number of lanes as this type, but …\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and with immediate.\nBitwise and not.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nGet the total number of bits used to represent this type.\nConditional select of bits.\nRetrieves all the parameters for a <code>Block</code> currently …\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise or.\nBitwise or with immediate.\nBitwise or not.\nGet the (minimum, maximum) values represented by each lane …\nIndirect branch via jump table.\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor not.\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nDirect function call.\nCalling convention.\nIndirect function call.\nCalls libc.memcmp\nCalls libc.memcpy\nCalls libc.memmove\nCalls libc.memset\nRound floating point round to integral, towards positive …\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nChanges the destination of a jump instruction after …\nTest if the <code>checked</code> bit is set.\nClear the signature so it is identical to a fresh one …\nClears all entries in this jump table, except for the …\nCount leading sign bits.\nCount leading zero bits.\nWill this function be defined nearby, such that it will …\nReturns a number composed of the magnitude of self and the …\nReturns a number composed of the magnitude of self and the …\nCreates a new <code>Block</code> and returns its reference.\nCreates a dynamic stack slot in the function, to be used by\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nCreates a sized stack slot in the function, to be used by …\nCount trailing zeros.\nGet the block that this builder is currently at.\nReturns a <code>FuncCursor</code> pointed at the current position ready …\nEncodes an assembly debug trap.\nIn order to use a variable (by calling …\nRegister a new definition of a user variable. The type of …\nFetch the default block for this jump table.\nMutable access to the default block of this jump table.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nReturn a value that can display the contents of this jump …\nGet a type with the same number of lanes as this type, but …\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nConvert a dynamic vector type to a fixed one.\nOptimised <code>Self::call_memcmp</code> for small copies.\nOptimised memcpy or memmove for small copies.\nCalls libc.memset\nEnable a boolean setting or apply a preset.\nReturn endianness of the memory access.  This will return …\nMake sure that the current block is inserted in the layout.\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point addition.\nFloating point comparison.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConverts floating point scalars to signed integer.\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nDeclare that translation of the current function is …\nRound floating point round to integral, towards negative …\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point multiplication.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nThe function currently being built. This field is public …\nGet the address of a function.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nReturn the type of this global.\nCompute the value of global GV.\nGet a type with the same number of lanes as this type, but …\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nGet the index that was used to create this entity …\nIndex of this type, for use with hash tables etc.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nReturns an object with the <code>InstBuilder</code> trait that allows …\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nReturns the result values of an instruction.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nReference verification.\nIs this the INVALID type?\nIs this a lane type?\nDoes this return more than one normal value? (Pre-struct …\nCheck if the value is a NaN.\nCheck if the value is a NaN. For Ieee64, this means …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self has a negative sign, including -0.0, …\nReference verification.\nIs this a ref type?\nIs this a special type?\nReturns <code>true</code> if and only if the current <code>Block</code> is sealed …\nIs this a SIMD vector type?\nReturns true if self is positive or negative zero\nReturns true if self is positive or negative zero\nInstruction Set Architectures.\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nReturns an iterator to the jump table, excluding the …\nReturns an iterator that allows modifying each value, …\nJump.\nThe kind of stack slot.\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nLoad from memory at <code>p + Offset</code>.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nName of the external function.\nRound floating point round to integral, towards nearest …\nReturn self negated.\nReturn self negated.\nCreate a new entity reference from a small integer. This …\nCreates a new <code>FunctionBuilder</code> structure that will operate …\nCreates a <code>FunctionBuilderContext</code> structure. The structure …\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new jump table with the provided blocks.\nCreate a new empty set of flags.\nCreate a stack slot with the specified byte size and …\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nTest if this memory operation cannot trap.\nNull constant value for reference types.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nThe arguments passed to the function.\nPopulation count\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nA resumable trap.\nA resumable trap to be called when the passed condition is …\nReturn from the function.\nDirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left by immediate.\nRotate right.\nRotate right by immediate.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nEffectively calls seal_block on all unsealed blocks in the …\nDeclares that all the predecessors of this block are known.\nConditional select.\nConditional select intended for Spectre guards.\nSet the string value of any setting by name.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet the <code>checked</code> bit.\nMark a block as “cold”.\nSet endianness of the memory access.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>.\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nSet the source location that should be assigned to all new …\nSet label for <code>Value</code>\nShared settings module.\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSign extend this immediate as if it were a signed integer …\nRetrieves the signature with reference <code>sigref</code> previously …\nCall signature of function.\nSize of stack slot in bytes.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nSigned integer maximum.\nSigned integer minimum.\nMultiply integers signed with overflow out. <code>of</code> is set when …\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nSplit the lane width in half and double the number of …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nReturns the square root of self.\nReturns the square root of self.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract with signed saturation.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nAfter the call to this function, new instructions will be …\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nGet the corresponding string condition code for the IntCC …\nTerminate execution unconditionally.\nGet the trap code to report if this memory access traps.\nTrap when non-zero.\nTrap when zero.\nReturn the pointer type for the given target triple.\nRound floating point round to integral, towards zero.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nCreate a set of flags representing an access from a “…\nDeclares the type of a variable, so that it can be used …\nRegisters a new definition of a user variable. This …\nReturns the Cranelift IR necessary to use a previously …\nCommon types for the Cranelift code generator.\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer minimum.\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the corresponding IntCC with the signed component …\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nReturns the Cranelift IR value corresponding to the …\nCreate a new external name from a user-defined external …\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nConvert a fixed vector type to a dynamic one.\nReduce a vector to a scalar integer.\nTrue iff:\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag, returning new flags.\nCreate a new <code>Ieee32</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>x</code>.\nSet the <code>checked</code> bit, returning new flags.\nSet endianness of the memory access, returning new flags.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>, returning …\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nSet the <code>readonly</code> flag, returning new flags.\nConfigures these flags with the specified trap code <code>code</code>.\nCreate a new Variable with the given index.\nGet the corresponding IntCC with the equal component …\nReturn self negated.\nReturn self negated.\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nSpecifies the memory flags to be used by the load. …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nThe string names of all the supported, but possibly not …\nMac aarch64 calling convention, which is a tweaked aarch64 …\nType alias of <code>IsaBuilder</code> used for building Cranelift’s …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nFunction alignment specifications as required by an ISA, …\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nThe type of a polymorphic TargetISA object which is ’…\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nSupports tail calls, not ABI-stable.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nWasmtime equivalent of SystemV, not ABI-stable.\nThe winch calling convention, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nARM 64-bit Instruction Set Architecture.\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nIs the calling convention extending the Apple aarch64 ABI?\nIs the calling convention extending the Windows Fastcall …\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new Builder from a TargetIsa, copying all flags …\nGet the information needed by frontends producing …\nReturns the minimum function alignment and the preferred …\nReturns whether this ISA has a native …\nReturns whether the CLIF <code>x86_blendv</code> instruction is …\nReturns whether the CLIF <code>x86_pmaddubsw</code> instruction is …\nReturns whether the CLIF <code>x86_pmulhrsw</code> instruction is …\nReturns whether the CLIF <code>x86_pshufb</code> instruction is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nMap a regalloc::Reg to its corresponding DWARF register.\nThe minimum alignment required by an ISA, where all …\nGet the name of this ISA.\nCreates a new ISA-builder from its components, namely the …\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nA “preferred” alignment which should be used for more …\nrisc-v 64-bit Instruction Set Architecture.\nDoes this calling convention support tail calls?\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGenerate a <code>Capstone</code> context for disassembling bytecode for …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nRepresents information relating to function unwinding.\nCreate a polymorphic TargetIsa from this specific …\nX86_64-bit Instruction Set Architecture.\nAn AArch64 backend.\nReturns the argument unchanged.\nThis module defines aarch64-specific machine instruction …\nCalls <code>U::from(self)</code>.\nCreate a new <code>isa::Builder</code>.\nCreate a new AArch64 backend with the given (shared) flags.\nAArch64 Settings.\nInternal type ALUOp: defined at src/isa/aarch64/inst.isle …\nInternal type ALUOp3: defined at src/isa/aarch64/inst.isle …\nInternal type AMode: defined at src/isa/aarch64/inst.isle …\nInternal type APIKey: defined at src/isa/aarch64/inst.isle …\nAdvanced SIMD modified immediate as used by the vector …\nAdvanced SIMD modified immediate as used by MOVI/MVNI.\nArithmetic shift right.\n21-bit offset for ADR (get address of label). PC-rel, …\nAlways executed.\nInternal type AtomicRMWLoopOp: defined at …\nInternal type AtomicRMWOp: defined at …\nInternal type BitOp: defined at src/isa/aarch64/inst.isle …\n14-bit branch offset (conditional branches). PC-rel, …\n19-bit branch offset (conditional branches). PC-rel, …\n26-bit branch offset (unconditional branches). PC-rel, …\nA branch target. Either unresolved (basic-block index) or …\nInternal type BranchTargetType: defined at …\nAdditional information for CallInd instructions, left out …\nAdditional information for (direct) Call instructions, …\nCondition for conditional branches.\nCondition: the given condition-code test is true.\nThe kind of conditional branch: the common-case-optimized …\nEqual.\nAn extend operator for a register.\nFloating-point unit immediate left shift.\nInternal type FPUOp1: defined at src/isa/aarch64/inst.isle …\nInternal type FPUOp2: defined at src/isa/aarch64/inst.isle …\nInternal type FPUOp3: defined at src/isa/aarch64/inst.isle …\nA floating-point unit (FPU) operation with two args, a …\nA floating-point unit (FPU) operation with two args, a …\nFloating-point unit immediate right shift.\nInternal type FpuRoundMode: defined at …\nInternal type FpuToIntOp: defined at …\nSigned greater or equal to.\nSigned greater than.\nUnsigned greater than.\nUnsigned greater than or equal to.\nA shifted immediate value in ‘imm12’ format: supports …\nAn immediate for logical instructions.\nAn immediate for shift instructions.\nInternal type MInst: defined at src/isa/aarch64/inst.isle …\nInternal type IntToFpuOp: defined at …\nLogical shift left.\nLogical shift right.\nAn unresolved reference to a Label, as passed into …\nDifferent forms of label references for different …\n19-bit offset for LDR (load literal). PC-rel, offset is …\nSigned less than or equal.\nUnsigned less than.\nUnsigned less than or equal to.\nSigned less than.\nMaximum shift for shifted-register operands.\nAn address that refers to a label within a <code>MachBuffer</code>, for …\nA reference to some memory address.\nMinus, negative.\nA 16-bit immediate for a MOVZ instruction, with a …\nInternal type MoveWideOp: defined at …\nAn immediate that represents the NZCV flags.\nNot equal.\nCondition: given register is nonzero.\nAlways executed.\nType used to communicate the operand size of a machine …\nAn address in the code, a constant pool or jumptable, with …\n32-bit PC relative constant offset (from address of …\nInternal type PairAMode: defined at …\nPositive or zero.\nRotate right.\nA fixed PC offset.\nAdditional information for <code>return_call[_ind]</code> instructions, …\nA signed, scaled 7-bit offset.\na 9-bit signed offset.\nSigned extend byte.\nSigned extend halfword.\nSigned extend word.\nSigned extend doubleword.\nType used to communicate the size of a scalar SIMD &amp; FP …\nA shift operator for a register or immediate.\nA shift operator with an amount, guaranteed to be within …\nA shift operator amount.\n128-bit.\n16-bit.\n16-bit, 4 lanes.\n16-bit, 8 lanes.\n32-bit.\n32-bit.\n32-bit, 2 lanes.\n32-bit, 4 lanes.\n64-bit.\n64-bit.\n64-bit, 2 lanes.\n8-bit.\n8 bit, 16 lanes.\n8-bit, 8 lanes.\nShift left and insert. Rd |= Rn &lt;&lt; #imm\nShift left and insert. Rd |= Rn &lt;&lt; #imm\nInternal type TestBitAndBranchKind: defined at …\nAn unsigned, scaled 12-bit offset.\nAn unsigned 5-bit immediate.\nUnsigned right shift. Rd = Rn &lt;&lt; #imm\nUnsigned right shift. Rd = Rn &lt;&lt; #imm\nUnsigned extend byte.\nUnsigned extend halfword.\nUnsigned extend word.\nUnsigned extend doubleword.\nNo signed overflow.\nInternal type VecALUModOp: defined at …\nInternal type VecALUOp: defined at …\nInternal type VecExtendOp: defined at …\nInternal type VecLanesOp: defined at …\nInternal type VecMisc2: defined at …\nInternal type VecPairOp: defined at …\nInternal type VecRRLongOp: defined at …\nInternal type VecRRNarrowOp: defined at …\nInternal type VecRRPairLongOp: defined at …\nInternal type VecRRRLongModOp: defined at …\nInternal type VecRRRLongOp: defined at …\nInternal type VecShiftImmModOp: defined at …\nInternal type VecShiftImmOp: defined at …\nType used to communicate the size of a vector operand.\nSigned overflow.\nCondition: given register is zero.\nShift amount.\nShift amount.\nGet the shift amount.\nAArch64 ISA definitions: instruction arguments.\nReturn the target’s label, if it is a label-based target.\nReturn the target’s offset, if specified, or zero if …\nReturn the target’s offset, if specified, or zero if …\nReturn the target’s offset, if specified, or zero if …\nBits for encoding.\nBits for encoding.\nBits for encoding.\nBits for encoding.\nEncoded bits.\nGet the encoding of this shift op.\nEncoding of this op.\nReturn the machine encoding of this condition.\nReturn the operand size in bits.\nThe immediate bits.\nThe value.\nCallee calling convention.\nCallee calling convention.\nThe number of bytes that the callee will pop from the …\nThe number of bytes that the callee will pop from the …\nCaller calling convention.\nCaller calling convention.\nClobbers register set.\nClobbers register set.\nComplements this branch condition to act on the opposite …\nReturn values from the call instruction.\nReturn values from the call instruction.\nCall destination.\nAArch64 ISA: binary code emission.\nReturns the encoding of the immediate.\nReturns encoding of the immediate.\nReturns the encoding of the <code>auti{key}</code> instruction used to …\nReturns bits ready for encoding: (N:1, R:6, S:6)\nReturns bits ready for encoding.\nReturn the encoding bit that is used by some …\nReturn the encoding bits that are used by some SIMD …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a needed width to the smallest size that fits.\nGet the vector operand size with the given scalar size as …\nConvert from an integer type into the smallest size that …\nReturn the encoding bits that are used by some scalar FP …\nGeneric constructor for a load (zero-extending where …\nGeneric constructor for a store.\n6-bit shift amount.\nBits for 12-bit “imm” field in e.g. AddI.\nAArch64 ISA definitions: immediate constants.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an immediate for the bitwise-inverted value.\nReturn the inverted condition.\nReturn the inverted branch condition.\n32-bit case?\n64-bit case?\nReturns true if the VectorSize is 128-bits.\nAPI key to use to restore the return address, if any.\nGet the scalar operand size that corresponds to a lane of …\nLane size in bits.\nLane size in bits.\nCreate an instruction that loads a constant, using one of …\nMask down to a given number of bits.\nThe maximum unsigned value representable in a value of …\nCreate a SImm7Scaled from a raw offset and the known scale …\nCreate a signed 9-bit offset from a full-range value, if …\nCreate a UImm12Scaled from a raw offset and the known …\nCreate a new shiftop shift amount, if possible.\nCompute a Imm12 from raw bits, if possible.\nCompute an ImmLogic from raw bits, if possible.\nCreate an ImmShift from raw bits, if possible.\nConstruct a MoveWideConst from an arbitrary 64-bit …\nConstruct an ASIMDMovModImm from an arbitrary 64-bit …\nConstruct an ASIMDFPModImm from an arbitrary 64-bit …\nCreate an unsigned 5-bit immediate from u8.\nCreate a floating-point unit immediate left shift from u8.\nCreate a floating-point unit immediate right shift from u8.\nCreate a <code>MoveWideCosnt</code> from a given shift, if possible.\nWhat type does this load or store instruction access in …\n<code>N</code> flag.\nReturn the narrowed version of the scalar size.\nCreate a new NZCV flags representation.\nCreate a new shift operator with an amount.\nThe size of the new stack frame’s stack arguments. This …\nGet the shift op.\nGet the assembly mnemonic for this opcode.\nInstruction opcode.\nInstruction opcode.\nInstruction opcode.\nConvert to an integer operand size.\nGet the integer operand size that corresponds to a lane of …\n<code>S</code> field: element size and element bits.\nMemory reference using an address in a register.\nMemory reference using <code>reg1 + sizeof(ty) * reg2</code> as an …\nFunction pointer for indirect call.\n<code>R</code> field: rotate amount.\nmultiplied by the size of this type\nRegister interpretation bit. When 0, the register is …\nResult is <code>bits</code> shifted 16*shift bits to the left.\nWhether the immediate bits are shifted left by 12 or not.\nBits for 2-bit “shift” field in e.g. AddI.\nWas this constructed for a 32-bit or 64-bit instruction?\nConvert to I32, I64, or I128.\nReturn a type with the same size as this scalar.\nArguments to the call instruction.\nArguments to the call instruction.\nArguments to the call instruction.\nSigned value of immediate.\nValue after scaling.\nGet the actual value that this immediate corresponds to.\nReturns the value that this immediate represents.\nGet the immediate value.\nReturns the value that this immediate represents.\nReturn the shift amount.\nThe value.\nThe value.\nReturn the widened version of the scalar size.\nCreate a zero immediate of this format.\nCreate a zero immediate of this format.\nCreate a zero immediate of this format.\nArithmetic shift right.\nAlways executed.\nA branch target. Either unresolved (basic-block index) or …\nCondition for conditional branches.\nCondition: the given condition-code test is true.\nThe kind of conditional branch: the common-case-optimized …\nEqual.\nAn extend operator for a register.\nSigned greater or equal to.\nSigned greater than.\nUnsigned greater than.\nUnsigned greater than or equal to.\nLogical shift left.\nLogical shift right.\nAn unresolved reference to a Label, as passed into …\nSigned less than or equal.\nUnsigned less than.\nUnsigned less than or equal to.\nSigned less than.\nAn address that refers to a label within a <code>MachBuffer</code>, for …\nA reference to some memory address.\nMinus, negative.\nNot equal.\nCondition: given register is nonzero.\nAlways executed.\nType used to communicate the operand size of a machine …\nAn address in the code, a constant pool or jumptable, with …\nInternal type PairAMode: defined at …\nPositive or zero.\nRotate right.\nA fixed PC offset.\nSigned extend byte.\nSigned extend halfword.\nSigned extend word.\nSigned extend doubleword.\nType used to communicate the size of a scalar SIMD &amp; FP …\nA shift operator for a register or immediate.\nA shift operator with an amount, guaranteed to be within …\nA shift operator amount.\n128-bit.\n16-bit.\n16-bit, 4 lanes.\n16-bit, 8 lanes.\n32-bit.\n32-bit.\n32-bit, 2 lanes.\n32-bit, 4 lanes.\n64-bit.\n64-bit.\n64-bit, 2 lanes.\n8-bit.\n8 bit, 16 lanes.\n8-bit, 8 lanes.\nInternal type TestBitAndBranchKind: defined at …\nUnsigned extend byte.\nUnsigned extend halfword.\nUnsigned extend word.\nUnsigned extend doubleword.\nNo signed overflow.\nType used to communicate the size of a vector operand.\nSigned overflow.\nCondition: given register is zero.\nConstant state used during function compilation.\nState carried between emissions of a sequence of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMemory addressing mode finalization: convert “special” …\nCreate a constant state for emission of instructions.\nAdvanced SIMD modified immediate as used by the vector …\nAdvanced SIMD modified immediate as used by MOVI/MVNI.\nFloating-point unit immediate left shift.\nFloating-point unit immediate right shift.\nA shifted immediate value in ‘imm12’ format: supports …\nAn immediate for logical instructions.\nAn immediate for shift instructions.\nA 16-bit immediate for a MOVZ instruction, with a …\nAn immediate that represents the NZCV flags.\nA signed, scaled 7-bit offset.\na 9-bit signed offset.\nAn unsigned, scaled 12-bit offset.\nAn unsigned 5-bit immediate.\nShift amount.\nShift amount.\nThe immediate bits.\nThe value.\n6-bit shift amount.\nLane size in bits.\nLane size in bits.\n<code>N</code> flag.\n<code>S</code> field: element size and element bits.\n<code>R</code> field: rotate amount.\nmultiplied by the size of this type\nResult is <code>bits</code> shifted 16*shift bits to the left.\nWhether the immediate bits are shifted left by 12 or not.\nWas this constructed for a 32-bit or 64-bit instruction?\nThe value.\nThe value.\nFlags group <code>arm64</code>.\nCreate a <code>settings::Builder</code> for the arm64 settings group.\nReturns the argument unchanged.\nHas Large System Extensions (FEAT_LSE) support.\nHas Pointer authentication (FEAT_PAuth) support; enables …\nCalls <code>U::from(self)</code>.\nIterates the setting values.\nCreate flags arm64 settings group.\nGet a view of the boolean predicates.\nUse pointer authentication instructions to sign function …\nIf function return address signing is enabled, then apply …\nUse the B key with pointer authentication instructions …\nUse Branch Target Identification (FEAT_BTI) instructions.\nAn riscv64 backend.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>isa::Builder</code>.\nCreate a new riscv64 backend with the given (shared) flags.\nDefines if the aarch64-specific pointer authentication …\nCFA-based unwind information used on SystemV.\nThe frame-pointer register for this architecture has just …\nNo unwind info.\nThe frame-pointer register for this architecture has just …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystemV CIE/FDE unwind info.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nExpected unwind info type.\nUnwind pseudoinstruction used in VCode backends: …\nWindows X64 Unwind info\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOut-of-line data for calls, to keep the size of <code>Inst</code> down.\nConstant state used during emissions of a sequence of …\nState carried between emissions of a sequence of …\nInternal type MInst: defined at src/isa/x64/inst.isle line …\nInstruction operand sub-components (aka “parts”): …\nThe calling convention of the callee.\nThe number of bytes that the callee will pop from the …\nRegisters clobbered by this call, as per its calling …\nCreates a new x86-64 common information entry (CIE).\nRegister defs of this call.\nEmit unwind info for an x86 target.\nContains the encoding machinery for the various x64 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a constant state for emission of instructions.\nx86 Settings.\nRegister uses of this call.\nAdd with carry.\nAdd operation.\nInternal type AluRmROpcode: defined at …\nSome basic ALU operations.\nInternal type Amode: defined at src/isa/x64/inst.isle line …\nBitwise AND operation.\nInternal type Avx512Opcode: defined at …\nInternal type AvxOpcode: defined at src/isa/x64/inst.isle …\n&lt; unsigned\n&lt;= unsigned\nByte -&gt; Longword.\nByte -&gt; Quadword.\nBit-scan forward.\nBit-scan reverse.\nThese indicate condition code tests.  Not all are …\nCMP instruction: compute <code>a - b</code> and set flags from result.\nComparison operations.\nA virtual offset to a constant that will be emitted in the …\nInternal type DivSignedness: defined at …\nEqual comparison.\nThis defines the ways a value can be extended: either …\nThese indicate ways of extending (widening) a value, using …\nEncode the ways that floats can be compared. This is used …\nAn x64 memory fence kind.\nAn extension trait for converting <code>Writable&lt;Reg&gt;</code> to …\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nAn immediate operand.\n8-bit immediate operand.\nA newtype wrapper around <code>Imm8Reg</code>.\nAn operand which is either an 8-bit integer immediate or a …\nA newtype wrapper around <code>Imm8Reg</code>.\nA (virtual) offset into the incoming argument area.\n&lt; signed\n&lt;= signed\n<code>lfence</code> instruction (“Load Fence”)\nLongword -&gt; Quadword.\nLess than comparison.\nLess than or equal comparison.\nCounts leading zeroes (Leading Zero CouNT).\n<code>mfence</code> instruction (“Memory Fence”)\nA memory operand.\nA memory operand.\n= unsigned\nunsigned\n= signed\nsigned\nno overflow\nnot parity\nnot-negative\nnot-zero\nNo value.\nNo value.\nNo extension.\nNot equal comparison.\noverflow\nAn operand’s size in bits.\nOptional writable Gpr.\nOptional writable Gpr.\nBitwise inclusive OR.\nOrdered.\nparity\nCounts the number of ones (POPulation CouNT).\nA real amode.\nA register operand.\nA register operand.\nA register operand.\nAn operand which is either an integer Register or a value …\nAn operand which is either an integer Register, a value in …\nLeft rotation.\nRight rotation.\nRound down mode.\nEncode the rounding modes used as part of the Rounding …\nRound to nearest mode.\nRound up mode.\nRound to zero mode.\nnegative\n<code>sfence</code> instruction (“Store Fence”)\nInteger subtraction with borrow.\nThese indicate the form of a scalar shift/rotate: left, …\nLeft shift.\nReplicates the sign bit in the most significant bits.\nInserts zeros in the most significant bits.\nSign-extend.\n16-bit.\n32-bit.\n64-bit.\n8-bit.\nA (virtual) offset to the slot area of the function frame, …\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nSome SSE operations requiring 2 operands r/m and r.\nInteger subtraction.\nA Memory Address. These denote a 64-bit value only. Used …\nTEST instruction: compute <code>a &amp; b</code> and set flags from result.\nAn extension trait for converting <code>Writable{Xmm,Gpr}</code> to …\nCounts trailing zeroes (Trailing Zero CouNT).\nInternal type UnaryRmRImmVexOpcode: defined at …\nUnary operations requiring register or memory and register …\nInternal type UnaryRmRVexOpcode: defined at …\nUnordered.\nUnordered or greater than comparison.\nUnordered of greater than or equal comparison.\nWord -&gt; Longword.\nWord -&gt; Quadword.\nWritable Gpr.\nWritable Gpr.\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nA newtype wrapper around <code>RegMemImm</code>.\nBitwise exclusive OR.\nzero\nZero-extend.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert <code>Writable&lt;Reg&gt;</code> to <code>Writable{Xmm,Gpr}</code>.\nCreate an immediate operand.\nCreate an immediate sign-extended and register addressing …\nCreate a sign-extended-32-to-64 with register and shift …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a memory operand.\nCreate a memory operand.\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate a real addressing mode.\nCreate a register operand.\nCreate a register operand.\nGet this newtype’s underlying <code>Reg</code>.\nGet this newtype’s underlying <code>Reg</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert <code>Writable{Xmm,Gpr}</code> to <code>Writable&lt;Reg&gt;</code>.\nWhat is the “TupleType” of this opcode, which affects …\nSet the specified MemFlags to the Amode.\nThe 8-bit immediate value.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe immediate value.\nThe downward offset from the start of the incoming …\nThe offset into the slot area.\nThe encoding formats in this module all require a way of …\nEncodes EVEX instructions. These instructions are those …\nAdd 1 byte to the code section.\nAdd 2 bytes to the code section.\nAdd 4 bytes to the code section.\nAdd 8 bytes to the code section.\nEncodes instructions in the standard x86 encoding mode. …\nEncodes VEX instructions. These instructions are those …\nDefines the EVEX context for the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits …\nConstructs an EVEX-encoded instruction using a builder …\nDefines the EVEX masking behavior; masking support is …\nThe EVEX format allows defining rounding control in the <code>L&#39;</code> …\nThe EVEX format allows choosing a vector length in the <code>L&#39;</code> …\nDescribe the register index to use. This wrapper is a …\nEncode the <code>aaa</code> bits for merging with the P2 byte.\nEncode the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits 6:4 of EVEX P2 byte) …\nEmit the EVEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction . Note that there are …\nSet the opcode map byte of the instruction: None | 0F | …\nSet the mask to use. See section 2.6 in the Intel Software …\nConstruct a default EVEX instruction.\nSet the instruction opcode byte.\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the “tuple type” which is used for 8-bit scaling …\nSet the <code>vvvvv</code> register; some instructions allow using this …\nSet the W bit, typically used to indicate an instruction …\nEncode the <code>z</code> bit for merging with the P2 byte.\nWe may need to include one or more legacy prefix bytes …\nNo prefix bytes.\nAllows using the same opcode byte in different “opcode …\nA small bit field to record a REX prefix specification:\nOperand Size Override – here, denoting “16-bit …\nOperand size override and Lock.\nOperand size override and same effect as F3.\nThe Lock prefix.\nREPNE, but no specific meaning here – is just an opcode …\nREP/REPE, but no specific meaning here – is just an …\nRequire that the REX prefix is emitted.\nEmit the rex prefix if the referenced register would …\nCreates a new RexPrefix for which the REX.W bit will be …\nEmit a unary instruction.\nEmit a ternary instruction.\nEmit a binary instruction.\nEncode the ModR/M byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if the REX prefix must always be emitted.\nTrue if 64-bit operands are used.\nBy default, set the W field, and don’t always emit.\nConstructs a VEX-encoded instruction using a builder …\nThe VEX format allows choosing a vector length in the <code>L</code> …\nEmit the VEX-encoded instruction to the provided buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte. Overrides a previously set Self::imm_reg …\nSet the imm byte when used for a register. The reg bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction.\nSet the opcode map byte of the instruction: None | 0F | …\nConstruct a default VEX instruction.\nSet the instruction opcode byte.\nSome instructions use the ModRM.reg field as an opcode …\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvv</code> register; some instructions allow using this …\nSet the W bit, denoted by <code>.W1</code> or <code>.W0</code> in the instruction …\nFlags group <code>x86</code>.\nCreate a <code>settings::Builder</code> for the x86 settings group.\nReturns the argument unchanged.\nHas support for AVX. AVX: CPUID.01H:ECX.AVX[bit 28]\nHas support for AVX2. AVX2: CPUID.07H:EBX.AVX2[bit 5]\nHas support for AVX512BITALG. AVX512BITALG: …\nHas support for AVX512DQ. AVX512DQ: CPUID.07H:EBX.AVX512DQ[…\nHas support for AVX512F. AVX512F: CPUID.07H:EBX.AVX512F[…\nHas support for AVX512VMBI. AVX512VBMI: …\nHas support for AVX512VL. AVX512VL: CPUID.07H:EBX.AVX512VL[…\nHas support for BMI1. BMI1: CPUID.(EAX=07H, …\nHas support for BMI2. BMI2: CPUID.(EAX=07H, …\nHas support for FMA. FMA: CPUID.01H:ECX.FMA[bit 12]\nHas support for LZCNT. LZCNT: CPUID.EAX=80000001H:ECX.LZCNT…\nHas support for POPCNT. POPCNT: CPUID.01H:ECX.POPCNT[bit 23…\nHas support for SSE3. SSE3: CPUID.01H:ECX.SSE3[bit 0]\nHas support for SSE4.1. SSE4.1: CPUID.01H:ECX.SSE4_1[bit 19…\nHas support for SSE4.2. SSE4.2: CPUID.01H:ECX.SSE4_2[bit 20…\nHas support for SSSE3. SSSE3: CPUID.01H:ECX.SSSE3[bit 9]\nCalls <code>U::from(self)</code>.\nIterates the setting values.\nCreate flags x86 settings group.\nGet a view of the boolean predicates.\nComputed predicate <code>x86.has_avx()</code>.\nComputed predicate <code>x86.has_avx() &amp;&amp; x86.has_avx2()</code>.\nComputed predicate <code>x86.has_avx512bitalg()</code>.\nComputed predicate <code>x86.has_avx512dq()</code>.\nComputed predicate <code>x86.has_avx512f()</code>.\nComputed predicate <code>x86.has_avx512vbmi()</code>.\nComputed predicate <code>x86.has_avx512vl()</code>.\nComputed predicate <code>x86.has_bmi1()</code>.\nComputed predicate <code>x86.has_bmi2()</code>.\nComputed predicate <code>x86.has_avx() &amp;&amp; x86.has_fma()</code>.\nComputed predicate <code>x86.has_lzcnt()</code>.\nComputed predicate <code>x86.has_popcnt() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate <code>x86.has_sse41()</code>.\nComputed predicate <code>x86.has_sse41() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate <code>x86.has_ssse3()</code>.\n<code>apple_aarch64</code>.\nNo setting by this name exists.\nType mismatch for setting (e.g., setting an enum setting …\nThis is not a valid value for this setting.\nThe setting is a boolean.\nCollect settings values based on a template.\n<code>coff</code>.\n<code>cold</code>.\nA string-based configurator for settings groups.\n<code>elf_gd</code>.\nThe setting is an enumeration.\nContains the error value\n<code>fast</code>.\nFlags group <code>shared</code>.\nWrapper containing flags and optionally a <code>TargetIsa</code> trait …\n<code>inline</code>.\n<code>isa_default</code>.\nValues for <code>shared.libcall_call_conv</code>.\n<code>macho</code>.\n<code>none</code>.\n<code>none</code>.\nThe setting is a number.\nContains the success value\nValues for <code>shared.opt_level</code>.\n<code>outline</code>.\nA reference to just the boolean predicates of a settings …\nThe setting is a preset.\n<code>probestack</code>.\nValues for <code>shared.probestack_strategy</code>.\nAn error produced when changing a setting.\nA result returned when changing a setting.\nRepresents an available builder setting.\nRepresents the kind of setting.\n<code>speed</code>.\n<code>speed_and_size</code>.\n<code>system_v</code>.\nValues for <code>shared.tls_model</code>.\nRepresents a setting value.\n<code>windows_fastcall</code>.\nReturns a slice with all possible OptLevel values.\nReturns a slice with all possible TlsModel values.\nReturns a slice with all possible LibcallCallConv values.\nReturns a slice with all possible ProbestackStrategy …\nGets the boolean value if the value is from a boolean …\nGets the enum value if the value is from an enum setting.\nGets the numerical value if the value is from a num …\nThe log2 of the size to insert dummy padding between basic …\nCreate a <code>settings::Builder</code> for the shared settings group.\nThe description of the setting.\nImplementation details for generated code.\nEnable a boolean setting or apply a preset.\nDo redundant-load optimizations with alias analysis.\nEnable the use of atomic instructions\nEnable the use of floating-point instructions.\nEnable Spectre mitigation on heap bounds checks.\nEnable additional checks for debugging the incremental …\nEnable the use of jump tables in generated machine code.\nEnable various ABI extensions defined by LLVM’s behavior.\nEnable NaN canonicalization.\nEnable proof-carrying code translation validation.\nEnable the use of the pinned register.\nEnable the use of stack probes for supported calling …\nEnable safepoint instruction insertions.\nEnable Spectre mitigation on table bounds checks.\nRun the Cranelift IR verifier at strategic times during …\nFlags are always present.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable Position-Independent Code generation.\nThe ISA may not be present.\nIterates the available settings in the builder.\nIterates the setting values.\nGets the kind of setting.\nThe kind of the setting.\nDefines the calling convention to use for LibCalls call …\nGenerate CFG metadata for machine code.\nThe name of the setting associated with this value.\nThe name of the setting.\nCreate a new builder with defaults and names from the …\nCreate a new view of a precomputed predicate vector.\nCreate flags shared settings group.\nOptimization level for generated code.\nGet a view of the boolean predicates.\nPreserve frame pointers\nThe log2 of the size of the stack guard region.\nControls what kinds of stack probes are emitted.\nEnable the symbolic checker for register allocation.\nEnable verbose debug logs for regalloc2.\nSet the string value of any setting by name.\nExtract contents of builder once everything is configured.\nCheck a numbered predicate.\nDefines the model used to perform TLS accesses.\nGenerate unwind information.\nUse colocated libcalls.\nBuilds a string from the current value\nThe supported values of the setting (for enum values).\nA boolean setting only uses one bit, numbered from LSB.\nA setting descriptor holds the information needed to …\nThe different kind of settings along with descriptor bits …\nAn Enum setting uses a range of enumerators.\nA numerical setting uses the whole byte.\nA preset is not an individual setting, it is a collection …\nAn instruction group template.\nDefault values.\nThe description of the setting.\nList of setting descriptors.\nAdditional details, depending on the kind of setting.\nUnion of all enumerators.\nGet enumerators corresponding to a <code>Details::Enum</code>.\nFormat a setting value as a TOML string. This is mostly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash table of settings.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a detail is a Detail::Preset. Useful because the …\nName of the instruction group.\nLower snake-case name of setting as defined in meta.\nOffset of byte containing this setting.\nPairs of (mask, value) for presets.\n0-7.\nFirst enumerator in the ENUMERATORS table.\nNumerical value of last enumerator, allowing for 1-256 …\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nAn opaque reference type with 32 bits.\nAn opaque reference type with 64 bits.\nThe type of an SSA value.")